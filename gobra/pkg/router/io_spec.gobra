package router

import (
    "gobra/lib/slayers"
    "gobra/lib/addr"
    "gobra/lib/slayers/path"
    "gobra/lib/slayers/path/scion"
    "gobra/lib/slayers/path/onehop"
    underlayconn "gobra/lib/underlay/conn"
)

pred P(pl Place, ghost s mset[Fact]) {
    P_readBatch(pl, s) &&
    P_decodePkt(pl, s) &&
    P_decodeIntraBFD(pl, s) &&
    P_decodeInterBFD(pl, s) &&
    P_sendIntraBFD(pl, s) &&
    P_sendInterBFD(pl, s) &&
    P_processOHP(pl, s) &&
    P_processSCION(pl, s) &&
    P_packPkt(pl, s) &&
    P_writeBatch(pl, s)
}

pred P_readBatch(pl Place, ghost s mset[Fact]) {
    readBatch_p(pl) && P(get_readBatch_t1(pl), s union ToMset(get_readBatch_msgs(pl)))
}

pred P_decodePkt(pl Place, ghost s mset[Fact]) {
    forall m AbsMessage, scn AbsSCION :: { decodePkt_p(pl, m, scn) } (
        (inFact(m) in s) && G_decodePkt(m, scn)) ==> 
    decodePkt_p(pl, m, scn) && P(get_decodePkt_t1(pl, m, scn), U(s, mset[Fact]{inFact(m)}, mset[Fact]{decodedPktFact(scn)}))
}

pred P_decodeIntraBFD(pl Place, ghost s mset[Fact]) {
    forall scn AbsSCION, bfd AbsBFD :: { decodeIntraBFD_p(pl, scn, bfd) } (
        (decodedPktFact(scn) in s) && G_decodeIntraBFD(scn, bfd)) ==>
    decodeIntraBFD_p(pl, scn, bfd) && P(get_decodeIntraBFD_t1(pl, scn, bfd), U(s, mset[Fact]{decodedPktFact(scn)}, mset[Fact]{decodedIntraBFDFact(bfd)}))
}

pred P_decodeInterBFD(pl Place, ghost s mset[Fact]) {
    forall scn AbsSCION, bfd AbsBFD :: { decodeInterBFD_p(pl, scn, bfd) } (
        (decodedPktFact(scn) in s) && G_decodeInterBFD(scn, bfd)) ==>
    decodeInterBFD_p(pl, scn, bfd) && P(get_decodeInterBFD_t1(pl, scn, bfd), U(s, mset[Fact]{decodedPktFact(scn)}, mset[Fact]{decodedInterBFDFact(bfd)}))
}
pred P_sendIntraBFD(pl Place, ghost s mset[Fact]) {
    forall bfd AbsBFD :: { sendIntraBFD_p(pl, bfd) } (
        (decodedIntraBFDFact(bfd) in s)) ==>
    sendIntraBFD_p(pl, bfd) && P(get_sendIntraBFD_t1(pl, bfd), s setminus mset[Fact]{decodedIntraBFDFact(bfd)})
}

pred P_sendInterBFD(pl Place, ghost s mset[Fact]) {
    forall bfd AbsBFD :: { sendInterBFD_p(pl, bfd) } (
        (decodedInterBFDFact(bfd) in s)) ==>
    sendInterBFD_p(pl, bfd) && P(get_sendInterBFD_t1(pl, bfd), s setminus mset[Fact]{decodedInterBFDFact(bfd)} )
}

pred P_processOHP(pl Place, ghost s mset[Fact]) {
    forall scn AbsSCION, pr AbsProcessResult, rc ResultCase, ia addr.IA, egressIDs dict[uint16]AbsConn, ic AbsConn :: { processOHP_p(pl, scn, pr, rc, ia, egressIDs, ic) } (
        (decodedPktFact(scn) in s) && (localIAFact(ia) in s) && (internalConnFact(ic) in s) && 
        (supportedEgressIDsFact(egressIDs) in s) && G_processOHP(scn, pr, rc, s, ia, egressIDs, ic)) ==>
    processOHP_p(pl, scn, pr, rc, ia, egressIDs, ic) && P(get_processOHP_t1(pl, scn, pr, rc, ia, egressIDs, ic), U(s, mset[Fact]{decodedPktFact(scn)}, mset[Fact]{processedPktFact(pr)}))
}

pred P_processSCION(pl Place, ghost s mset[Fact]) {
    forall scn AbsSCION, pr AbsProcessResult, rc ResultCase, ia addr.IA, egressIDs dict[uint16]AbsConn, ic AbsConn :: { processSCION_p(pl, scn, pr, rc, ia, egressIDs, ic) } (
        (decodedPktFact(scn) in s) && (localIAFact(ia) in s) && (internalConnFact(ic) in s) && 
        (supportedEgressIDsFact(egressIDs) in s) && G_processSCION(scn, pr, rc, s, ia, egressIDs, ic)) ==>
    processSCION_p(pl, scn, pr, rc, ia, egressIDs, ic) && P(get_processSCION_t1(pl, scn, pr, rc, ia, egressIDs, ic), U(s, mset[Fact]{decodedPktFact(scn)}, mset[Fact]{processedPktFact(pr)}))
}

pred P_packPkt(pl Place, ghost s mset[Fact]) {
    forall pr AbsProcessResult, m AbsMessage :: { packPkt_p(pl, pr, m) } (
        (processedPktFact(pr) in s) && G_packPkt(pr, m)) ==>
    packPkt_p(pl, pr, m) && P(get_packPkt_t1(pl, pr, m), U(s, mset[Fact]{processedPktFact(pr)}, mset[Fact]{outFact(m)}))
}

pred P_writeBatch(pl Place, ghost s mset[Fact]) {
    forall m AbsMessage :: (outFact(m) # s) > 0 ==> writeBatch_p(pl, m) && P(get_writeBatch_t1(pl, m), s setminus mset[Fact]{outFact(m)})
}

// helper functions

ghost
ensures forall i int :: 0 <= i && i < len(s) ==> inFact(s[i]) in res
decreases _
pure func ToMset(s seq[AbsMessage]) (res mset[Fact])

// guard methods

ghost
ensures res == (GetAbsMessagePayload(m) == GetAbsSCIONRawPkt(scn))
decreases
pure func G_decodePkt(m AbsMessage, scn AbsSCION) (res bool) {
    return GetAbsMessagePayload(m) == GetAbsSCIONRawPkt(scn)
}

ghost
ensures res == true
decreases _
pure func G_decodeIntraBFD(scn AbsSCION, bfd AbsBFD) (res bool)

ghost
ensures res == true
decreases _
pure func G_decodeInterBFD(scn AbsSCION, bfd AbsBFD) (res bool)

ghost
decreases
pure func G_processOHP(scn AbsSCION, pr AbsProcessResult, rc ResultCase, s mset[Fact], ia addr.IA, supportedEgressIDs dict[uint16]AbsConn, internalConn AbsConn) (res bool) {
    return ( ((rc == Transit) && (GetAbsHopConsEgress(GetAbsOHPPathFirstHop(GetAbsSCIONOHPPath(scn))) in domain(supportedEgressIDs))) ==> (GetAbsProcessResultEgressID(pr) == GetAbsHopConsEgress(GetAbsOHPPathFirstHop(GetAbsSCIONOHPPath(scn)))) ) &&
    ( ((rc == Transit) && (GetAbsHopConsEgress(GetAbsOHPPathFirstHop(GetAbsSCIONOHPPath(scn))) in domain(supportedEgressIDs))) ==> (GetAbsProcessResultBatchConn(pr) == supportedEgressIDs[GetAbsProcessResultEgressID(pr)]) ) &&
    ( ((rc == Inbound) && (ia == GetAbsSCIONDstIA(scn))) ==> (GetAbsProcessResultEgressID(pr) == 0) ) &&
    ( ((rc == Inbound) && (ia == GetAbsSCIONDstIA(scn))) ==> (GetAbsProcessResultBatchConn(pr) == internalConn) )
}

ghost
decreases
pure func G_processSCION(scn AbsSCION, pr AbsProcessResult, rc ResultCase,s mset[Fact], ia addr.IA, supportedEgressIDs dict[uint16]AbsConn, internalConn AbsConn) (res bool) {
    return ((( (rc == Inbound) && (ia == GetAbsSCIONDstIA(scn)) && (GetAbsRawPathCurrHopIdx(GetAbsSCIONRawPath(scn)) + 1 == GetAbsRawPathNumHops(GetAbsSCIONRawPath(scn)))) ==> (GetAbsProcessResultEgressID(pr) == 0) ) &&
    ( ((rc == Inbound) && (ia == GetAbsSCIONDstIA(scn)) && (GetAbsRawPathCurrHopIdx(GetAbsSCIONRawPath(scn)) + 1 == GetAbsRawPathNumHops(GetAbsSCIONRawPath(scn)))) ==> (GetAbsProcessResultBatchConn(pr) == internalConn) ) &&
    ( ((rc == Transit) && (GetAbsInfoConsDir(GetAbsRawPathCurrInfo(GetAbsSCIONRawPath(scn))) && GetAbsHopConsEgress(GetAbsRawPathCurrHop(GetAbsSCIONRawPath(scn))) in domain(supportedEgressIDs))) ==> (GetAbsProcessResultEgressID(pr) == GetAbsHopConsEgress(GetAbsRawPathCurrHop(GetAbsSCIONRawPath(scn)))) ) &&
    ( ((rc == Transit) && (!GetAbsInfoConsDir(GetAbsRawPathCurrInfo(GetAbsSCIONRawPath(scn))) && GetAbsHopConsIngress(GetAbsRawPathCurrHop(GetAbsSCIONRawPath(scn))) in domain(supportedEgressIDs))) ==> (GetAbsProcessResultEgressID(pr) == GetAbsHopConsIngress(GetAbsRawPathCurrHop(GetAbsSCIONRawPath(scn)))) ) &&
    ( ((rc == Transit) && (GetAbsInfoConsDir(GetAbsRawPathCurrInfo(GetAbsSCIONRawPath(scn))) && GetAbsHopConsEgress(GetAbsRawPathCurrHop(GetAbsSCIONRawPath(scn))) in domain(supportedEgressIDs))) ==> (GetAbsProcessResultBatchConn(pr) == supportedEgressIDs[GetAbsProcessResultEgressID(pr)]) ) &&
    ( ((rc == Transit) && (!GetAbsInfoConsDir(GetAbsRawPathCurrInfo(GetAbsSCIONRawPath(scn))) && GetAbsHopConsIngress(GetAbsRawPathCurrHop(GetAbsSCIONRawPath(scn))) in domain(supportedEgressIDs))) ==> (GetAbsProcessResultBatchConn(pr) == supportedEgressIDs[GetAbsProcessResultEgressID(pr)]) ) &&
    ( ((rc == TransitFromOtherBR)) ==> (GetAbsProcessResultEgressID(pr) == 0 && GetAbsProcessResultBatchConn(pr) == internalConn) ) &&
    ( ((rc == TransitFromOtherBR)) ==> (GetAbsProcessResultBatchConn(pr) == internalConn) ))
}

ghost
decreases
pure func G_packPkt(pr AbsProcessResult, m AbsMessage) (res bool) {
    return GetAbsProcessResultOutPkt(pr) == GetAbsMessagePayload(m)
}

// lemmas

ghost
requires acc(scn.Mem(), 1/1000)
requires data == unfolding acc(scn.Mem(), 1/1000) in scn.RawPkt
ensures acc(scn.Mem(), 1/1000)
ensures absBytes == GetAbsSCIONRawPkt(ToAbsSCION(scn))
decreases _
func relateDataToSCION(data []byte, scn *slayers.SCION, absBytes seq[byte])

ghost
requires acc(s.Mem(), 1/1000)
preserves acc(DataPlaneMutexInvariant(d), _)
ensures acc(s.Mem(), 1/1000)
ensures (s.getDstIA()).Equal(d.GetLocalAI()) ==> localIA == GetAbsSCIONDstIA(absSCION)
decreases _
func relateDstIAToLocalIA(s *slayers.SCION, d *DataPlane, localIA addr.IA, absSCION AbsSCION)

ghost
requires acc(p.Mem(), 1/1000)
ensures acc(p.Mem(), 1/1000)
ensures (int(p.GetCurrHF()) + 1 == p.GetNumHops()) ==> (GetAbsRawPathCurrHopIdx(GetAbsSCIONRawPath(absSCION)) + 1) == GetAbsRawPathNumHops(GetAbsSCIONRawPath(absSCION))
decreases _
func relateLastHopToNumHops(p *scion.Raw, absSCION AbsSCION)

ghost
requires acc(scn, 1/1000)
requires acc(p.Mem(), 1/1000)
requires p == scn.Path
ensures acc(scn, 1/1000)
ensures acc(p.Mem(), 1/1000)
ensures GetAbsHopConsEgress(GetAbsOHPPathFirstHop(GetAbsSCIONOHPPath(absSCION))) ==  p.GetFristHopConsEgress()
decreases _
func relateOHPEgressID(scn *slayers.SCION, p *onehop.Path, absSCION AbsSCION)

ghost
requires acc(pr.Mem(), 1/1000)
ensures acc(pr.Mem(), 1/1000)
ensures  pr.EgressID == GetAbsProcessResultEgressID(ToAbsProcessResult(pr))
decreases _
func relateProcessResultEgressID(pr processResult)

ghost
requires acc(pr.Mem(), 1/1000)
requires pr.OutConn != nil
ensures acc(pr.Mem(), 1/1000)
ensures GetAbsProcessResultBatchConn(ToAbsProcessResult(pr)) == unfolding acc(pr.Mem(), _) in ToAbsConn(pr.OutConn)
decreases _
func relateProcessResultOutConn(pr processResult)

ghost
requires acc(spp.Mem(), 1/1000)
ensures acc(spp.Mem(), 1/1000)
ensures GetAbsHopConsEgress(GetAbsRawPathCurrHop(GetAbsSCIONRawPath(absSCION))) == unfolding acc(spp.Mem(), _) in unfolding acc(path.HopFieldInv(spp.hopField), _) in spp.hopField.ConsEgress
ensures GetAbsHopConsIngress(GetAbsRawPathCurrHop(GetAbsSCIONRawPath(absSCION))) == unfolding acc(spp.Mem(), _) in unfolding acc(path.HopFieldInv(spp.hopField), _) in spp.hopField.ConsIngress
decreases _
func relateCurrHop(absSCION AbsSCION, spp *scionPacketProcessor)

ghost
requires acc(spp.Mem(), 1/1000)
ensures acc(spp.Mem(), 1/1000)
ensures GetAbsInfoConsDir(GetAbsRawPathCurrInfo(GetAbsSCIONRawPath(absSCION))) == unfolding acc(spp.Mem(), _) in spp.infoField.ConsDir
func relateCurrInfo(absSCION AbsSCION, spp *scionPacketProcessor)

ghost
requires acc(bc.Mem(), _)
requires IsInternalConn(bc)
ensures acc(bc.Mem(), _)
ensures internalBatchConn == ToAbsConn(bc)
decreases _
func relateInternalBatchConn(bc BatchConn, internalBatchConn AbsConn)

ghost
requires acc(bc.Mem(), _)
requires IsValidBatchConnIntf(intf, bc)
ensures acc(bc.Mem(), _)
ensures intf in domain(cons) && cons[intf] == ToAbsConn(bc)
decreases _
func relateBatchConn(intf uint16, bc BatchConn, cons dict[uint16]AbsConn)

ghost
requires acc(m.MemSend(), 1/1000)
requires len(m) == 1
requires unfolding acc(m.MemSend(), _) in unfolding acc((&m[0]).MemSend(), _) in (m[0].Buffers)[0] == pr.OutPkt
ensures acc(m.MemSend(), 1/1000)
ensures GetAbsProcessResultOutPkt(absPr) == unfolding acc(m.MemSend(), _) in GetAbsMessagePayload(ToAbsMessage_MemSend(&m[0]))
decreases _
func relateMessageSendPayload(absPr AbsProcessResult, pr processResult, m underlayconn.Messages)