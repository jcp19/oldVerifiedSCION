package router

import(
    . "gobra/io_verification/abstract"
)

type Fact domain {

    // each fact has a unique 'type':
    func getType(Fact) int

    // incoming Message
    func inFact(AbsMessage) Fact
    func getIn(Fact) AbsMessage

    // decoded Pkt
    func decodedPktFact(AbsSCION) Fact
    func getDecodedPktFact(Fact) AbsSCION

    // decoded Intra BFD
    func decodedIntraBFDFact(AbsBFD) Fact
    func getDecodedIntraBFDFact(Fact) AbsBFD

    // decoded Inter BFD
    func decodedInterBFDFact(AbsBFD) Fact
    func getDecodedInterBFDFact(Fact) AbsBFD

    // sent Intra BFD
    func sentIntraBFDFact(AbsBFD) Fact
    func getSentIntraBFDFact(Fact) AbsBFD

    // sent Intra BFD
    func sentInterBFDFact(AbsBFD) Fact
    func getSentInterBFDFact(Fact) AbsBFD

    // processed Pkt
    func processedPktFact(AbsProcessResult) Fact
    func getProcessedPktFact(Fact) AbsProcessResult

    // outgoing Message
    func outFact(AbsMessage) Fact
    func getOut(Fact) AbsMessage

    // inFact injective
    axiom {
        forall t AbsMessage :: { inFact(t) } getIn(inFact(t)) == t && getType(inFact(t)) == 0
    }
    // inFact injective
    axiom {
        forall t1, t2 AbsMessage :: t1 != t2 ==> inFact(t1) != inFact(t2)
    }

    // decodedPktFact injective
    axiom {
        forall t AbsSCION :: { decodedPktFact(t) } getDecodedPktFact(decodedPktFact(t)) == t && getType(decodedPktFact(t)) == 1
    }
    // decodedPktFact injective
    axiom {
        forall t1, t2 AbsSCION :: t1 != t2 ==> decodedPktFact(t1) != decodedPktFact(t2)
    }

    // decodedIntraBFDFact injective
    axiom {
        forall t AbsBFD :: { decodedIntraBFDFact(t) } getDecodedIntraBFDFact(decodedIntraBFDFact(t)) == t && getType(decodedIntraBFDFact(t)) == 2
    }
    // decodedIntraBFDFact injective
    axiom {
        forall t1, t2 AbsBFD :: t1 != t2 ==> decodedIntraBFDFact(t1) != decodedIntraBFDFact(t2)
    }

    // decodedInterBFDFact injective
    axiom {
        forall t AbsBFD :: { decodedInterBFDFact(t) } getDecodedInterBFDFact(decodedInterBFDFact(t)) == t && getType(decodedInterBFDFact(t)) == 3
    }
    // decodedInterBFDFact injective
    axiom {
        forall t1, t2 AbsBFD :: t1 != t2 ==> decodedInterBFDFact(t1) != decodedInterBFDFact(t2)
    }

    // sentIntraBFDFact injective
    axiom {
        forall t AbsBFD :: { sentIntraBFDFact(t) } getSentIntraBFDFact(sentIntraBFDFact(t)) == t && getType(sentIntraBFDFact(t)) == 4
    }
    // sentIntraBFDFact injective
    axiom {
        forall t1, t2 AbsBFD :: t1 != t2 ==> sentIntraBFDFact(t1) != sentIntraBFDFact(t2)
    }

    // sentInterBFDFact injective
    axiom {
        forall t AbsBFD :: { sentInterBFDFact(t) } getSentInterBFDFact(sentInterBFDFact(t)) == t && getType(sentInterBFDFact(t)) == 5
    }
    // sentInterBFDFact injective
    axiom {
        forall t1, t2 AbsBFD :: t1 != t2 ==> sentInterBFDFact(t1) != sentInterBFDFact(t2)
    }

    // processedPktFact injective
    axiom {
        forall t AbsProcessResult :: { processedPktFact(t) } getProcessedPktFact(processedPktFact(t)) == t && getType(processedPktFact(t)) == 6
    }
    // processedPktFact injective
    axiom {
        forall t1, t2 AbsProcessResult :: t1 != t2 ==> processedPktFact(t1) != processedPktFact(t2)
    }

    // outFact injective
    axiom {
        forall t AbsMessage :: { outFact(t) } getOut(outFact(t)) == t && getType(outFact(t)) == 7
    }
    // outFact injective
    axiom {
        forall t1, t2 AbsMessage :: t1 != t2 ==> outFact(t1) != outFact(t2)
    }
}

ghost
ensures res == l subset s
pure func G(s, l mset[Fact]) (res bool) {
    return l subset s
}

ghost
ensures res == (s setminus l) union r
pure func U(s, l, r mset[Fact]) (res mset[Fact]) {
    return (s setminus l) union r
}

ghost
ensures res == mset[Fact] {}
pure func EmptySet() (res mset[Fact]) {
    return mset[Fact] {}
}