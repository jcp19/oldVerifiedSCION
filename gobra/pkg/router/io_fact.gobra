package router

import (
    "gobra/lib/addr"
)

type Fact domain {

    // local IA of the border router
    func localIAFact(addr.IA) Fact
    func getLocalIAFact(Fact) addr.IA

    // supported Egress IDs of the border router
    func supportedEgressIDsFact(dict[uint16]AbsConn) Fact
    func getSupportedEgressIDs(Fact) dict[uint16]AbsConn

    // internal BatchConn interface of the border router
    func internalConnFact(AbsConn) Fact
    func getInternalConnFact(Fact) AbsConn

    // incoming Message
    func inFact(AbsMessage) Fact
    func getIn(Fact) AbsMessage

    // decoded Pkt
    func decodedPktFact(AbsSCION) Fact
    func getDecodedPktFact(Fact) AbsSCION

    // decoded Intra BFD
    func decodedIntraBFDFact(AbsBFD) Fact
    func getDecodedIntraBFDFact(Fact) AbsBFD

    // decoded Inter BFD
    func decodedInterBFDFact(AbsBFD) Fact
    func getDecodedInterBFDFact(Fact) AbsBFD

    // processed Pkt
    func processedPktFact(AbsProcessResult) Fact
    func getProcessedPktFact(Fact) AbsProcessResult

    // outgoing Message
    func outFact(AbsMessage) Fact
    func getOut(Fact) AbsMessage

    // inFact injective
    axiom {
        forall t AbsMessage :: { inFact(t) } getIn(inFact(t)) == t
    }

    // decodedPktFact injective
    axiom {
        forall t AbsSCION :: { decodedPktFact(t) } getDecodedPktFact(decodedPktFact(t)) == t
    }

    // decodedIntraBFDFact injective
    axiom {
        forall t AbsBFD :: { decodedIntraBFDFact(t) } getDecodedIntraBFDFact(decodedIntraBFDFact(t)) == t
    }

    // decodedInterBFDFact injective
    axiom {
        forall t AbsBFD :: { decodedInterBFDFact(t) } getDecodedInterBFDFact(decodedInterBFDFact(t)) == t
    }

    // processedPktFact injective
    axiom {
        forall t AbsProcessResult :: { processedPktFact(t) } getProcessedPktFact(processedPktFact(t)) == t
    }

    // outFact injective
    axiom {
        forall t AbsMessage :: { outFact(t) } getOut(outFact(t)) == t
    }

    // localIAFact injective
    axiom {
        forall ia addr.IA :: { localIAFact(ia) } getLocalIAFact(localIAFact(ia)) == ia
    }

    // supportedEgressIDs injective
    axiom {
        forall cons dict[uint16]AbsConn :: { supportedEgressIDsFact(cons) } getSupportedEgressIDs(supportedEgressIDsFact(cons)) == cons
    }

    // internalConn injective
    axiom {
        forall conn AbsConn :: { internalConnFact(conn) } getInternalConnFact(internalConnFact(conn)) == conn
    }
}

ghost
ensures res == (s setminus l) union r
decreases
pure func U(s, l, r mset[Fact]) (res mset[Fact]) {
    return (s setminus l) union r
}