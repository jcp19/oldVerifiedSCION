package router

import (
	// underlayconn "github.com/scionproto/scion/go/lib/underlay/conn"
	// (joao) leads to empty.head error if run without qualified import
	// "github.com/scionproto/scion/go/lib/topology"
	"gobra/lib/addr"
	"gobra/lib/slayers"
	"gobra/lib/slayers/path"
	"gobra/lib/slayers/path/scion"
	"gobra/lib/util"
	"gobra/lib/serrors"
	"gobra/lib/common"
	"sync"
	"net"
	"time"

	"dependencies/gopacket"
	"dependencies/gopacket/layers" // needed for predicates defined there
) 

var (
	// alreadySet                    = serrors.New("already set")
	// cannotRoute                   = serrors.New("cannot route, dropping pkt")
	// emptyValue                    = serrors.New("empty value")
	// malformedPath                 = serrors.New("malformed path content")
	// modifyExisting                = serrors.New("modifying a running dataplane is not allowed")
	// noSVCBackend                  = serrors.New("cannot find internal IP for the SVC")
	// unsupportedPathType           = serrors.New("unsupported path type")
	// unsupportedPathTypeNextHeader = serrors.New("unsupported combination")
	// noBFDSessionFound             = serrors.New("no BFD sessions was found")
	// noBFDSessionConfigured        = serrors.New("no BFD sessions have been configured")
	// errBFDDisabled                = serrors.New("BFD is disabled")
)

(scmpError) implements error {

	(s scmpError) Error() (err string) {
		err = s.Error()
	}
}

type scmpError struct {
	TypeCode slayers.SCMPTypeCode
	Cause    error
}

func (e scmpError) Error() string {
	// (lhalm) throws NodeNotInTree exception
	// err := serrors.New("scmp", "typecode", e.TypeCode, "cause", e.Cause)
	// return err.Error()
}

// Run starts running the dataplane. Note that configuration is not possible
// after calling this method.
func (d *DataPlane) Run() error {
/*
	d.mtx.Lock()
	d.running = true

	// d.initMetrics()

	read := func(ingressID uint16, rd BatchConn) {
		msgs := conn.NewReadMessages(inputBatchCnt)
        // (joao) Wildcards not supported, using "Wildcard" as a placeholder
		for Wildcard, msg := range msgs {
			// (joao) Make not supported
			// msg.Buffers[0] = make([]byte, bufSize)
			;
		}

		var scmpErr scmpError
		// (joao) Make not supported
		// metas := make([]conn.ReadMeta, inputBatchCnt)
		spkt := slayers.SCION{}
		buffer := gopacket.NewSerializeBuffer()
		// (joao) Make not supported
		// origPacket := make([]byte, bufSize)
		for d.running {
			pkts, err := rd.ReadBatch(msgs, metas)
			if err != nil {
                //(joao) string literals not supported
				//log.Debug("Failed to read batch", "err", err)
				// error metric
				continue
			}
			if pkts == 0 {
				continue
			}

            // (joao) Wildcards not supported, using "Wildcard" as a placeholder
			for wildcard, p := range msgs[:pkts] {
				origPacket = origPacket[:p.N]
				// TODO(karampok). Use meta for sanity checks.
                // (joao) array access here leads to parse error
				//p.Buffers[0] = p.Buffers[0][:p.N]
				//copy(origPacket[:p.N], p.Buffers[0])

				// input metric
				inputLabels := interfaceToMetricLabels(ingressID, d.localIA, d.neighborIAs)
				//d.Metrics.InputPacketsTotal.With(inputLabels).Inc()
				//d.Metrics.InputBytesTotal.With(inputLabels).Add(float64(p.N))

                // (joao) access to p.Buffers[0] leads to parser error
				// result, err := d.processPkt(ingressID, p.Buffers[0], p.Addr, spkt, origPacket, buffer)

				switch {
				case err == nil:
				case errors.As(err, &scmpErr):
					if !scmpErr.TypeCode.InfoMsg() {
                        // (joao) no support for string literals 
						// log.Debug("SCMP", "err", scmpErr, "dst_addr", p.Addr)
					}
					// SCMP go back the way they came.
					result.OutAddr = p.Addr
					result.OutConn = rd
				default:
                    // (joao) no support for string literals 
					// log.Debug("Error processing packet", "err", err)
					// d.Metrics.DroppedPacketsTotal.With(inputLabels).Inc()
                    //(joao) continue statement not supported
					// continue
				}
				if result.OutConn == nil { // e.g. BFD case no message is forwarded
                    //(joao) continue statement not supported
					// continue
				}
                // (joao) no support for wildcards
				wildcard, err = result.OutConn.WriteBatch(underlayconn.Messages([]ipv4.Message{{
					Buffers: [][]byte{result.OutPkt},
					Addr:    result.OutAddr,
				}}))
				if err != nil {
                    // (joao) no support for string literals 
					// log.Debug("Error writing packet", "err", err)
					// error metric
					continue
				}
				// ok metric
				// outputLabels := interfaceToMetricLabels(result.EgressID, d.localIA, d.neighborIAs)
				// d.Metrics.OutputPacketsTotal.With(outputLabels).Inc()
				// d.Metrics.OutputBytesTotal.With(outputLabels).Add(float64(len(result.OutPkt)))
			}

			// Reset buffers to original capacity.
            // (joao) no support for wildcards
			for wildcard, p := range msgs[:pkts] {
                // (joao) p.Buffers[0] leads to parser error
				// p.Buffers[0] = p.Buffers[0][:bufSize]
			}
		}
	}

	for k, v := range d.bfdSessions {
		go func(ifID uint16, c bfdSession) {
			defer log.HandlePanic()
			if err := c.Run(); err != nil && err != bfd.AlreadyRunning {
                // (joao) no support for parser errors
				//log.Error("BFD session failed to start", "ifID", ifID, "err", err)
                ; // (joao) semicolon keeps Gobra from throwing parser error (issue 93)
			}
		}(k, v)
	}
	for ifID, v := range d.external {
		go func(i uint16, c BatchConn) {
			defer log.HandlePanic()
			read(i, c)
		}(ifID, v)
	}
	go func(c BatchConn) {
		defer log.HandlePanic()
		read(0, c)
	}(d.internal)

	d.mtx.Unlock()
	for d.running {
		time.Sleep(time.Second)
	}
*/
	return nil
}

type BatchConn interface {
	// ReadBatch(underlayconn.Messages, []underlayconn.ReadMeta) (int, error)
	// WriteBatch(underlayconn.Messages) (int, error)
	Close() error
}

type DataPlane struct {
	external         map[uint16]BatchConn
	// linkTypes        map[uint16]topology.LinkType
	// neighborIAs      map[uint16]addr.IA
	internal         BatchConn
	internalIP       net.IP
	// internalNextHops map[uint16]net.Addr
	// svc              *services
	// macFactory       func() hash.Hash
	// bfdSessions      map[uint16]bfdSession
	localIA          addr.IA
	mtx              sync.Mutex
	running          bool
	// Metrics          *Metrics
}


func (d *DataPlane) processPkt(ingressID uint16, rawPkt []byte, srcAddr net.Addr, s slayers.SCION,
	origPacket []byte /*, buffer gopacket.SerializeBuffer*/) (processResult, error) //{

	// if err := s.DecodeFromBytes(rawPkt, gopacket.NilDecodeFeedback); err != nil {
	//	return processResult{}, err
	// }

//	buffer ignored for now
//	if err := buffer.Clear(); err != nil {
//        // (joao) changed in order to parse correctly
//        // return processResult{}, serrors.WrapStr("Failed to clear buffer", err)
//		return processResult{}, nil
//	}
	

	// switch s.PathType {
	//case slayers.PathTypeEmpty:

	/*
		if s.NextHdr == common.L4BFD {
			return processResult{}, d.processIntraBFD(srcAddr, s.Payload)
		}
		/ return processResult{}, serrors.WithCtx(unsupportedPathTypeNextHeader,
		  "type", s.PathType, "header", s.NextHdr)
		*/

	/*
	case slayers.PathTypeOneHop:
		if s.NextHdr == common.L4BFD {
            // (joao) parse error
			// ohp, ok := s.Path.(*onehop.Path)
            ohp, ok := nil, true
			if !ok {
				return processResult{}, malformedPath
			}
			return processResult{}, d.processInterBFD(ingressID, ohp, s.Payload)
		}
		return d.processOHP(ingressID, rawPkt, s, buffer)
	*/
	// (joao) assuming only a SCION path type
 	// case slayers.PathTypeSCION:
	//	return d.processSCION(ingressID, rawPkt, s, origPacket /*, buffer*/)
	/*
	default:
        // (joao) parse error
		// return processResult{}, serrors.WithCtx(unsupportedPathType, "type", s.PathType)
	*/
	// }
// }

requires typeOf(s.Path) == *scion.Raw
requires acc((s.Path).(*scion.Raw))
requires scion.bytesAcc(((s.Path).(*scion.Raw)).Raw)
requires gopacket.bytesAcc(origPacket)
requires acc(&d.external)
requires acc(&d.internalIP)
requires acc(&d.localIA)
requires acc(d.external)
requires buffer.Mem()
requires scion.bytesAcc(rawPkt)
requires slayers.InvariantSCION(s)
requires gopacket.bytesAcc(s.EmbeddedLayer.Contents)
requires (scion.MetaLen + (s.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((s.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
requires (scion.MetaLen + (s.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((s.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((s.Path).(*scion.Raw).Raw)
requires int((s.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF) >= 0
requires (scion.MetaLen + int((s.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((s.Path).(*scion.Raw).Raw)
func (d *DataPlane) processSCION(ingressID uint16, rawPkt []byte, s slayers.SCION,
	origPacket []byte, buffer gopacket.SerializeBuffer) (pr processResult, err error) {

	p@ := scionPacketProcessor{
		d:          d,
		ingressID:  ingressID,
		rawPkt:     rawPkt,
		scionLayer: s,
		origPacket: origPacket,
		buffer:     buffer,
	}
	return p.process()
}

// Establishes the restrictions on the scion packet processors
pred scionPacketProcessorP() {true}

type scionPacketProcessor struct {
	// d is a reference to the dataplane instance that initiated this processor.
	d *DataPlane
	// ingressID is the interface ID this packet came in, determined from the
	// socket.
	ingressID uint16
	// rawPkt is the raw packet, it is updated during processing to contain the
	// message to send out.
	rawPkt []byte

	// scionLayer is the SCION gopacket layer.
	scionLayer slayers.SCION

	// origPacket is the raw original packet, must not be modified.
	origPacket []byte

	// (joao) buffer ignored for now
	// buffer is the buffer that can be used to serialize gopacket layers.
	buffer gopacket.SerializeBuffer

	// path is the raw SCION path. Will be set during processing.
	path *scion.Raw

	// hopField is the current hopField field, is updated during processing.
	hopField *path.HopField
	// infoField is the current infoField field, is updated during processing.
	infoField *path.InfoField
	// segmentChange indicates if the path segment was changed during processing.
	segmentChange bool
}

requires acc(p)
requires typeOf(p.scionLayer.Path) == *scion.Raw
requires acc((p.scionLayer.Path).(*scion.Raw))
requires scion.bytesAcc(((p.scionLayer.Path).(*scion.Raw)).Raw)
requires gopacket.bytesAcc(p.origPacket)
requires acc(&p.d.external)
requires acc(&p.d.internalIP)
requires acc(&p.d.localIA)
requires acc(p.d.external)
requires p.buffer.Mem()
requires scion.bytesAcc(p.rawPkt)
requires slayers.InvariantSCION(p.scionLayer)
requires gopacket.bytesAcc(p.scionLayer.EmbeddedLayer.Contents)
requires (scion.MetaLen + (p.scionLayer.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
requires (scion.MetaLen + (p.scionLayer.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
requires int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF) >= 0
requires (scion.MetaLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
ensures acc(p)
ensures acc(p.path)
ensures gopacket.bytesAcc(p.origPacket)
ensures acc(&p.d.external)
ensures acc(&p.d.internalIP)
ensures acc(&p.d.localIA)
ensures acc(p.d.external)
ensures p.buffer.Mem()
ensures scion.bytesAcc(p.rawPkt)
ensures err == nil ==> typeOf(p.scionLayer.Path) == *scion.Raw
ensures err == nil ==> (p.scionLayer.Path).(*scion.Raw) == p.path
ensures err == nil ==> scion.bytesAcc(((p.scionLayer.Path).(*scion.Raw)).Raw)
ensures err == nil ==> slayers.InvariantSCION(p.scionLayer)
ensures err == nil ==> gopacket.bytesAcc(p.scionLayer.EmbeddedLayer.Contents)
ensures err == nil ==> (scion.MetaLen + (p.scionLayer.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
ensures err == nil ==> (scion.MetaLen + (p.scionLayer.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
ensures err == nil ==> int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF) >= 0
ensures err == nil ==> (scion.MetaLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
func (p *scionPacketProcessor) process() (pr processResult, err error) {
	if r, err := p.parsePath(); err != nil {
		return r, err
	}
	if r, err := p.validatePktLen(); err != nil {
		return r, err
	}
	if err := p.updateNonConsDirIngressSegID(); err != nil {
		return processResult{}, err
	}
	/* (joao) skip for now
	if r, err := p.verifyCurrentMAC(); err != nil {
		return r, err
	}
	*/
//	/* (joao) skip by now
//	if r, err := p.handleIngressRouterAlert(); err != nil {
//		return r, err
//	}
//	*/ 
//
//	// Inbound: pkts destined to the local IA.
//	if p.scionLayer.DstIA.Equal(p.d.localIA) && int(p.path.PathMeta.CurrHF)+1 == p.path.NumHops {
//		a, r, err := p.resolveInbound()
//		if err != nil {
//			return r, err
//		}
//		return processResult{OutConn: p.d.internal, OutAddr: a, OutPkt: p.rawPkt}, nil
//	}
//
//	// Outbound: pkts leaving the local IA.
//	// BRTransit: pkts leaving from the same BR different interface.
//	/* (joao) assuming no cross-over at this point
//	if p.path.IsXover() {
//		if r, err := p.doXover(); err != nil {
//			return r, err
//		}
//	}*/
//	if r, err := p.validateEgressID(); err != nil {
//		return r, err
//	}
//	// handle egress router alert before we check if it's up because we want to
//	// send the reply anyway, so that trace route can pinpoint the exact link
//	// that failed.
//	if r, err := p.handleEgressRouterAlert(); err != nil {
//		return r, err
//	}
//	if r, err := p.validateEgressUp(); err != nil {
//		return r, err
//	}
//
//	/* (joao) skipped for now, leads to parser error
//	egressID := p.egressInterface()
//	if c, ok := p.d.external[egressID]; ok {
//		if err := p.processEgress(); err != nil {
//			return processResult{}, err
//		}
//		return processResult{EgressID: egressID, OutConn: c, OutPkt: p.rawPkt}, nil
//	}
//	*/
//
//	// ASTransit: pkts leaving from another AS BR.
//
/*
	if a, ok := (p.d.internalNextHops)[egressID]; ok {
		return processResult{OutConn: p.d.internal, OutAddr: a, OutPkt: p.rawPkt}, nil
	}
	*/

//	/*
//	errCode := slayers.SCMPCodeUnknownHopFieldEgress
//	if !p.infoField.ConsDir {
//		errCode = slayers.SCMPCodeUnknownHopFieldIngress
//	}
//	*/
//	return p.packSCMP(
//		&slayers.SCMP{
//			TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeParameterProblem, errCode),
//		},
//		&slayers.SCMPParameterProblem{Pointer: p.currentHopPointer()},
//		cannotRoute,
//	)
}

pred DecodedIndexInvariants(decPath scion.Decoded) {
	0 <= decPath.BaseEmbedded.PathMeta.CurrINF && decPath.BaseEmbedded.PathMeta.CurrINF < len(decPath.InfoFields) &&
	0 <= decPath.BaseEmbedded.PathMeta.CurrHF && decPath.BaseEmbedded.PathMeta.CurrHF < len(decPath.HopFields) &&
	decPath.BaseEmbedded.NumINF == len(decPath.InfoFields) &&
	decPath.BaseEmbedded.NumHops == len(decPath.HopFields) &&
	decPath.BaseEmbedded.PathMeta.CurrINF < decPath.BaseEmbedded.NumINF &&
	decPath.BaseEmbedded.PathMeta.CurrHF < decPath.BaseEmbedded.NumHops
}

requires acc(p)
requires typeOf(p.scionLayer.Path) == *scion.Raw
requires acc((p.scionLayer.Path).(*scion.Raw))
requires scion.bytesAcc(((p.scionLayer.Path).(*scion.Raw)).Raw)
requires gopacket.bytesAcc(p.origPacket)
requires acc(&p.d.external)
requires acc(&p.d.internalIP)
requires acc(&p.d.localIA)
requires acc(p.d.external)
requires p.buffer.Mem()
requires scion.bytesAcc(p.rawPkt)
requires slayers.InvariantSCION(p.scionLayer)
requires gopacket.bytesAcc(p.scionLayer.EmbeddedLayer.Contents)
requires (scion.MetaLen + (p.scionLayer.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
requires (scion.MetaLen + (p.scionLayer.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
requires int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF) >= 0
requires (scion.MetaLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
ensures acc(p)
ensures err == nil ==> acc(p.infoField)
ensures err == nil ==> acc(p.hopField)
ensures acc(p.path)
ensures gopacket.bytesAcc(p.origPacket)
ensures acc(&p.d.external)
ensures acc(&p.d.internalIP)
ensures acc(&p.d.localIA)
ensures acc(p.d.external)
ensures p.buffer.Mem()
ensures scion.bytesAcc(p.rawPkt)
ensures err == nil ==> typeOf(p.scionLayer.Path) == *scion.Raw
ensures err == nil ==> (p.scionLayer.Path).(*scion.Raw) == p.path
ensures err == nil ==> scion.bytesAcc(((p.scionLayer.Path).(*scion.Raw)).Raw)
ensures err == nil ==> slayers.InvariantSCION(p.scionLayer)
ensures err == nil ==> gopacket.bytesAcc(p.scionLayer.EmbeddedLayer.Contents)
ensures err == nil ==> (scion.MetaLen + (p.scionLayer.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
ensures err == nil ==> (scion.MetaLen + (p.scionLayer.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
ensures err == nil ==> int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF) >= 0
ensures err == nil ==> (scion.MetaLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
func (p *scionPacketProcessor) parsePath() (pr processResult, err error) {
	var ok bool
	//(joao) causes parser error
	p.path, ok = (p.scionLayer.Path).(*scion.Raw) //p.scionLayer.Path.(*scion.Raw)
	if !ok {
		// TODO(lukedirtwalker) parameter problem invalid path?
		return processResult{}, nil//malformedPath
	}
	// var err error (lhalm) defined it as return value
	p.hopField, err = p.path.GetCurrentHopField(1/2)
	if err != nil {
		// TODO(lukedirtwalker) parameter problem invalid path?
		return processResult{}, err
	}
	p.infoField, err = p.path.GetCurrentInfoField(1/2)
	if err != nil {
		// TODO(lukedirtwalker) parameter problem invalid path?
		return processResult{}, err
	}
	if r, err := p.validateHopExpiry(); err != nil {
		return r, err
	}
	if r, err := p.validateIngressID(); err != nil {
		return r, err
	}
	return processResult{}, nil
}

requires acc(p)
requires acc(p.path)
requires acc(p.infoField)
requires acc(p.hopField)
requires gopacket.bytesAcc(p.origPacket)
requires acc(&p.d.external)
requires acc(&p.d.internalIP)
requires acc(&p.d.localIA)
requires acc(p.d.external)
requires p.buffer.Mem()
requires scion.bytesAcc(p.rawPkt)
requires slayers.InvariantSCION(p.scionLayer)
requires gopacket.bytesAcc(p.scionLayer.EmbeddedLayer.Contents)
requires typeOf(p.scionLayer.Path) == *scion.Raw
requires p.scionLayer.Path == p.path
requires scion.bytesAcc(((p.scionLayer.Path).(*scion.Raw)).Raw)
requires int(p.path.BaseEmbedded.PathMeta.CurrINF) >= 0
requires (scion.MetaLen + int(p.path.BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
requires (scion.MetaLen + p.path.BaseEmbedded.NumINF*path.InfoLen + int(p.path.BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
requires (scion.MetaLen + p.path.BaseEmbedded.NumINF*path.InfoLen + int(p.path.BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
ensures acc(p)
ensures acc(p.path)
ensures acc(p.infoField)
ensures acc(p.hopField)
ensures gopacket.bytesAcc(p.origPacket)
ensures acc(&p.d.external)
ensures acc(&p.d.internalIP)
ensures acc(&p.d.localIA)
ensures acc(p.d.external)
ensures p.buffer.Mem()
ensures scion.bytesAcc(p.rawPkt)
ensures err == nil ==> slayers.InvariantSCION(p.scionLayer)
ensures err == nil ==> typeOf(p.scionLayer.Path) == *scion.Raw
ensures err == nil ==> p.scionLayer.Path == p.path
ensures err == nil ==> scion.bytesAcc(((p.scionLayer.Path).(*scion.Raw)).Raw)
ensures err == nil ==> gopacket.bytesAcc(p.scionLayer.EmbeddedLayer.Contents)
ensures err == nil ==> int(p.path.BaseEmbedded.PathMeta.CurrINF) >= 0
ensures err == nil ==> (scion.MetaLen + int(p.path.BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
ensures err == nil ==> (scion.MetaLen + p.path.BaseEmbedded.NumINF*path.InfoLen + int(p.path.BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
ensures err == nil ==> (scion.MetaLen + p.path.BaseEmbedded.NumINF*path.InfoLen + int(p.path.BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
func (p *scionPacketProcessor) validateHopExpiry() (pr processResult, err error) {
	expiration := (util.SecsToTime(p.infoField.Timestamp)).Add(path.ExpTimeToDuration(p.hopField.ExpTime))
	expired := expiration.Before(time.Now())
	if !expired {
		return processResult{}, nil
	}
	// (lhalm) declare structs first for predicates
	// return p.packSCMP(
	// 	&slayers.SCMP{TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeParameterProblem,
	// 		slayers.SCMPCodePathExpired),
	// 	},
	// 	&slayers.SCMPParameterProblem{Pointer: p.currentHopPointer()},
	// 	// (lhalm) rename path to pathVar and explicitly use embedded struct
	// 	// serrors.New("expired hop", "cons_dir", p.infoField.ConsDir, "if_id", p.ingressID,
	// 	// 	"curr_inf", p.path.PathMeta.CurrINF, "curr_hf", p.path.PathMeta.CurrHF),
	// 	serrors.New("expired hop", "cons_dir", p.infoField.ConsDir, "if_id", p.ingressID,
	// 		"curr_inf", p.pathVar.BaseEmbedded.PathMeta.CurrINF, "curr_hf", p.pathVar.BaseEmbedded.PathMeta.CurrHF),
	// )assert acc((p.scionLayer.PathVar).(*scion.Raw))
	scmpH := &slayers.SCMP{
		TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeParameterProblem,
			slayers.SCMPCodeInvalidPacketSize),
	}
	scmpP := &slayers.SCMPParameterProblem{Pointer: 0}
	fold scmpP.Mem()
	fold scmpH.Mem()
	return p.packSCMP(
		scmpH,
		scmpP,
		// serrors.New("expired hop", "cons_dir", p.infoField.ConsDir, "if_id", p.ingressID,
		// 	"curr_inf", p.path.PathMeta.CurrINF, "curr_hf", p.path.PathMeta.CurrHF),
		serrors.New("expired hop", "cons_dir", p.infoField.ConsDir, "if_id", p.ingressID,
			"curr_inf", p.path.BaseEmbedded.PathMeta.CurrINF, "curr_hf", p.path.BaseEmbedded.PathMeta.CurrHF),
	)
}

requires acc(p)
requires acc(p.path)
requires acc(p.infoField)
requires acc(p.hopField)
requires gopacket.bytesAcc(p.origPacket)
requires acc(&p.d.external)
requires acc(&p.d.internalIP)
requires acc(&p.d.localIA)
requires acc(p.d.external)
requires p.buffer.Mem()
requires scion.bytesAcc(p.rawPkt)
requires slayers.InvariantSCION(p.scionLayer)
requires gopacket.bytesAcc(p.scionLayer.EmbeddedLayer.Contents)
requires typeOf(p.scionLayer.Path) == *scion.Raw
requires p.scionLayer.Path == p.path
requires int(p.path.BaseEmbedded.PathMeta.CurrINF) >= 0
requires (scion.MetaLen + int(p.path.BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
requires (scion.MetaLen + p.path.BaseEmbedded.NumINF*path.InfoLen + int(p.path.BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
requires (scion.MetaLen + p.path.BaseEmbedded.NumINF*path.InfoLen + int(p.path.BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
requires scion.bytesAcc(((p.scionLayer.Path).(*scion.Raw)).Raw)
ensures acc(p)
ensures acc(p.path)
ensures acc(p.infoField)
ensures acc(p.hopField)
ensures gopacket.bytesAcc(p.origPacket)
ensures acc(&p.d.external)
ensures acc(&p.d.internalIP)
ensures acc(&p.d.localIA)
ensures acc(p.d.external)
ensures p.buffer.Mem()
ensures scion.bytesAcc(p.rawPkt)
ensures err == nil ==> slayers.InvariantSCION(p.scionLayer)
ensures err == nil ==> typeOf(p.scionLayer.Path) == *scion.Raw
ensures err == nil ==> p.scionLayer.Path == p.path
ensures err == nil ==> scion.bytesAcc(((p.scionLayer.Path).(*scion.Raw)).Raw)
ensures err == nil ==> gopacket.bytesAcc(p.scionLayer.EmbeddedLayer.Contents)
ensures err == nil ==> int(p.path.BaseEmbedded.PathMeta.CurrINF) >= 0
ensures err == nil ==> (scion.MetaLen + int(p.path.BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
ensures err == nil ==> (scion.MetaLen + p.path.BaseEmbedded.NumINF*path.InfoLen + int(p.path.BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
ensures err == nil ==> (scion.MetaLen + p.path.BaseEmbedded.NumINF*path.InfoLen + int(p.path.BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
func (p *scionPacketProcessor) validateIngressID() (pr processResult, err error) {
	pktIngressID := p.hopField.ConsIngress
	errCode := slayers.SCMPCodeUnknownHopFieldIngress
	if !p.infoField.ConsDir {
		pktIngressID = p.hopField.ConsEgress
		errCode = slayers.SCMPCodeUnknownHopFieldEgress
	}
	if p.ingressID != 0 && p.ingressID != pktIngressID {
		// (lhalm) create structs first for predicates
		// return p.packSCMP(
		// 	&slayers.SCMP{
		// 		TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeParameterProblem, errCode),
		// 	},
		// 	&slayers.SCMPParameterProblem{Pointer: p.currentHopPointer()},
		// 	serrors.New("ingress interface invalid",
		// 		"pkt_ingress", pktIngressID, "router_ingress", p.ingressID),
		// )
		scmpH := &slayers.SCMP{
			TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeParameterProblem,
				slayers.SCMPCodeInvalidPacketSize),
		}
		scmpP := &slayers.SCMPParameterProblem{Pointer: 0}
		fold scmpP.Mem()
		fold scmpH.Mem()
		// return p.packSCMP(scmpH, scmpP, 
		// 	serrors.New("bad packet size",
		// 		"header", p.scionLayer.PayloadLen, "actual", len(p.scionLayer.EmbeddedLayer.Payload)),
		// )
		pr, err := p.packSCMP(scmpH, scmpP, 
			serrors.New("bad packet size",
				"header", p.scionLayer.PayloadLen, "actual", len(p.scionLayer.EmbeddedLayer.Payload)),
		)
		return pr, err
	}
	return processResult{}, nil
}

requires acc(p)
requires acc(p.path)
requires acc(p.infoField)
requires acc(p.hopField)
requires gopacket.bytesAcc(p.origPacket)
requires acc(&p.d.external)
requires acc(&p.d.internalIP)
requires acc(&p.d.localIA)
requires acc(p.d.external)
requires p.buffer.Mem()
requires scion.bytesAcc(p.rawPkt)
requires slayers.InvariantSCION(p.scionLayer)
requires gopacket.bytesAcc(p.scionLayer.EmbeddedLayer.Contents)
requires typeOf(p.scionLayer.Path) == *scion.Raw
requires p.scionLayer.Path == p.path
requires scion.bytesAcc(((p.scionLayer.Path).(*scion.Raw)).Raw)
requires int(p.path.BaseEmbedded.PathMeta.CurrINF) >= 0
requires (scion.MetaLen + int(p.path.BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
requires (scion.MetaLen + p.path.BaseEmbedded.NumINF*path.InfoLen + int(p.path.BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
requires (scion.MetaLen + p.path.BaseEmbedded.NumINF*path.InfoLen + int(p.path.BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
ensures acc(p)
ensures acc(p.path)
ensures acc(p.infoField)
ensures acc(p.hopField)
ensures gopacket.bytesAcc(p.origPacket)
ensures acc(&p.d.external)
ensures acc(&p.d.internalIP)
ensures acc(&p.d.localIA)
ensures acc(p.d.external)
ensures p.buffer.Mem()
ensures scion.bytesAcc(p.rawPkt)
ensures err == nil ==> typeOf(p.scionLayer.Path) == *scion.Raw
ensures err == nil ==> p.scionLayer.Path == p.path
ensures err == nil ==> scion.bytesAcc(((p.scionLayer.Path).(*scion.Raw)).Raw)
ensures err == nil ==> slayers.InvariantSCION(p.scionLayer)
ensures err == nil ==> gopacket.bytesAcc(p.scionLayer.EmbeddedLayer.Contents)
ensures err == nil ==> (scion.MetaLen + (p.scionLayer.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
ensures err == nil ==> (scion.MetaLen + (p.scionLayer.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
ensures err == nil ==> int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF) >= 0
ensures err == nil ==> (scion.MetaLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
func (p *scionPacketProcessor) validatePktLen() (pr processResult, err error) {
	if int(p.scionLayer.PayloadLen) == len(p.scionLayer.EmbeddedLayer.Payload) {
		return processResult{}, nil
	}
	// (lhalm) create structs first for predicates
	// return p.packSCMP(
	// 	&slayers.SCMP{
	// 		TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeParameterProblem,
	// 			slayers.SCMPCodeInvalidPacketSize),
	// 	},
	// 	&slayers.SCMPParameterProblem{Pointer: 0},
	// 	serrors.New("bad packet size",
	// 		"header", p.scionLayer.PayloadLen, "actual", len(p.scionLayer.EmbeddedLayer.Payload)),
	// )
	scmpH := &slayers.SCMP{
		TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeParameterProblem,
			slayers.SCMPCodeInvalidPacketSize),
	}
	scmpP := &slayers.SCMPParameterProblem{Pointer: 0}
	fold scmpP.Mem()
	fold scmpH.Mem()
	return p.packSCMP(scmpH, scmpP, 
		serrors.New("bad packet size",
			"header", p.scionLayer.PayloadLen, "actual", len(p.scionLayer.EmbeddedLayer.Payload)),
	)
}

preserves acc(&p.infoField) && acc(p.infoField)
preserves acc(&p.hopField) && acc(p.hopField)
preserves acc(&p.rawPkt)
preserves acc(&p.ingressID)
preserves acc(&p.buffer)
preserves acc(&p.path) && acc(&p.path.BaseEmbedded) && acc(&p.path.Raw)
preserves int(p.path.BaseEmbedded.PathMeta.CurrINF) >= 0
preserves (scion.MetaLen + int(p.path.BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len(p.path.Raw)
preserves scion.bytesAcc(p.path.Raw)
preserves scion.bytesAcc(p.rawPkt)
preserves p.buffer.Mem()
preserves acc(&p.scionLayer)
preserves slayers.InvariantSCION(p.scionLayer)
preserves gopacket.bytesAcc(p.scionLayer.EmbeddedLayer.Contents)
preserves typeOf(p.scionLayer.Path) == *scion.Raw
preserves (p.scionLayer.Path).(*scion.Raw) == p.path
preserves (scion.MetaLen + (p.scionLayer.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
preserves (scion.MetaLen + (p.scionLayer.Path).(*scion.Raw).BaseEmbedded.NumINF*path.InfoLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
preserves int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF) >= 0
preserves (scion.MetaLen + int((p.scionLayer.Path).(*scion.Raw).BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
func (p *scionPacketProcessor) updateNonConsDirIngressSegID() error {
	// against construction dir the ingress router updates the SegID, ifID == 0
	// means this comes from this AS itself, so nothing has to be done.
	// TODO(lukedirtwalker): For packets destined to peer links this shouldn't
	// be updated.
	if !p.infoField.ConsDir && p.ingressID != 0 {
		p.infoField.UpdateSegID(p.hopField.Mac)
		// (lhalm) add explicit baseEmbedded
		// if err := p.path.SetInfoField(p.infoField, int(p.path.PathMeta.CurrINF)); err != nil {
		if err := p.path.SetInfoField(p.infoField, int(p.path.BaseEmbedded.PathMeta.CurrINF), 1/2); err != nil {
			return serrors.WrapStr("update info field", err)
		}
		// (lhalm) take address to adhere with changed method signature
		if err := updateSCIONLayer(p.rawPkt, &p.scionLayer, p.buffer); err != nil {
			return err
		}
	}
	return nil
}

requires acc(p)
requires acc(p.path)
requires acc(p.infoField)
requires acc(p.hopField)
requires gopacket.bytesAcc(p.origPacket)
requires acc(&p.d.external)
requires acc(&p.d.internalIP)
requires acc(&p.d.localIA)
requires acc(p.d.external)
requires p.buffer.Mem()
requires scion.bytesAcc(p.rawPkt)
requires scmpP.Mem()
requires scmpH.Mem()
requires slayers.InvariantSCION(p.scionLayer)
requires gopacket.bytesAcc(p.scionLayer.EmbeddedLayer.Contents)
requires typeOf(p.scionLayer.Path) == *scion.Raw
requires p.scionLayer.Path == p.path
requires scion.bytesAcc(((p.scionLayer.Path).(*scion.Raw)).Raw)
requires int(p.path.BaseEmbedded.PathMeta.CurrINF) >= 0
requires (scion.MetaLen + int(p.path.BaseEmbedded.PathMeta.CurrINF)*path.InfoLen)+path.InfoLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
requires (scion.MetaLen + p.path.BaseEmbedded.NumINF*path.InfoLen + int(p.path.BaseEmbedded.PathMeta.CurrHF)*path.HopLen) >= 0
requires (scion.MetaLen + p.path.BaseEmbedded.NumINF*path.InfoLen + int(p.path.BaseEmbedded.PathMeta.CurrHF)*path.HopLen) + path.HopLen < len((p.scionLayer.Path).(*scion.Raw).Raw)
ensures acc(p)
ensures acc(p.path)
ensures acc(p.infoField)
ensures acc(p.hopField)
ensures gopacket.bytesAcc(p.origPacket)
ensures acc(&p.d.external)
ensures acc(&p.d.internalIP)
ensures acc(&p.d.localIA)
ensures acc(p.d.external)
ensures p.buffer.Mem()
ensures scion.bytesAcc(p.rawPkt)
ensures err != nil
func (p *scionPacketProcessor) packSCMP(scmpH *slayers.SCMP, scmpP gopacket.SerializableLayer, cause error) (pr processResult, err error) {
	// (lhalm) the following block is moved to the packSCMPHelper1 function
	// parse everything to see if the original packet was an SCMP error.
	// var (
	// 	scionLayer@ slayers.SCION
	// 	udpLayer@   slayers.UDP
	// 	hbhExtn@    slayers.HopByHopExtn
	// 	e2eExtn@    slayers.EndToEndExtn
	// 	scmpLayer@  slayers.SCMP
	// )
	// parser := gopacket.NewDecodingLayerParser(
	// 	0 /* slayers.LayerTypeSCION */, &scionLayer, &udpLayer, &hbhExtn, &e2eExtn, &scmpLayer,
	// )
	// decoded := make([]gopacket.LayerType, 5)
	// assert forall i int :: 0 <= i && i < len(decoded) ==> acc(&decoded[i])
	// requires acc(decoded) && forall i int :: 0 <= i && i < len(*decoded) ==> acc(&(*decoded)[i])
	// if err := parser.DecodeLayers(p.origPacket, &decoded); err != nil {
	// 	if _, ok := err.(gopacket.UnsupportedLayerType); !ok {
	// 		return processResult{}, nil //serrors.WrapStr("decoding packet", err)
	// 	}
	// }
	// in reply to an SCMP error do nothing:
	// (lhalm) global variable slayers.LayerTypeSCMP not supportet at the moment
	// if decoded[len(decoded)-1] == slayers.LayerTypeSCMP && !scmpLayer.TypeCode.InfoMsg() {
	// 	return processResult{}, serrors.WrapStr("SCMP error for SCMP error pkt -> DROP", cause)
	// }
	p.packSCMPHelper1()

	// (lhalm): Add BaseEmbedded due to missing composition
	// the quoted packet is the packet in its current state
	// if err := p.path.SetInfoField(p.infoField, int(p.path.PathMeta.CurrINF)); err != nil {
	// 	return processResult{}, serrors.WrapStr("update info field", err)
	// }
	if err := p.path.SetInfoField(p.infoField, int(p.path.BaseEmbedded.PathMeta.CurrINF), 1/2); err != nil {
		return processResult{}, serrors.WrapStr("update info field", err)
	}
	// (lhalm): Add BaseEmbedded due to missing composition
	// if err := p.path.SetHopField(p.hopField, int(p.path.PathMeta.CurrHF)); err != nil {
	// 	return processResult{}, serrors.WrapStr("update hop field", err)
	// }
	if err := p.path.SetHopField(p.hopField, int(p.path.BaseEmbedded.PathMeta.CurrHF), 1/2); err != nil {
		return processResult{}, serrors.WrapStr("update hop field", err)
	}
	if err := p.buffer.Clear(); err != nil {
		return processResult{}, err
	}
	if err := p.scionLayer.SerializeTo(p.buffer, gopacket.SerializeOptions{}); err != nil {
		return processResult{}, err
	}
	// quoteLen is used to limit the size of the quote buffer, the final quote
	// length is calculated inside the scmpPacker.
	quoteLen := len(p.origPacket)
	if quoteLen > slayers.MaxSCMPPacketLen {
		quoteLen = slayers.MaxSCMPPacketLen
	}
	// (lhalm) causes #nontermination# within 2 hours
	// quote := make([]byte, quoteLen)
	var quote []byte
	// inhale forall i int :: 0 <= i && i < (quoteLen) ==> acc(&quote[i])
	// updated := p.buffer.Bytes()
	// copy(quote[:len(updated)], updated)
	// copy(quote[len(updated):], p.origPacket[len(updated):quoteLen])
	_, external := (p.d.external)[p.ingressID]
	rawSCMP, err  := scmpPacker{
		internalIP: p.d.internalIP,
		localIA:    p.d.localIA,
		origPacket: p.origPacket,
		ingressID:  p.ingressID,
		scionL:     &p.scionLayer,
		buffer:     p.buffer,
		quote:      quote,
	}.prepareSCMP(
		scmpH,
		scmpP,
		external,
		cause,
		p.path,
	)
	return processResult{OutPkt: rawSCMP}, err
}

// (lhalm) introduced to try to shorten verification time. No success
// pure func emptySCION() slayers.SCION //{
// 	return slayers.SCION{}
// }

requires acc(&p.origPacket)
requires gopacket.bytesAcc(p.origPacket)
ensures acc(&p.origPacket)
ensures gopacket.bytesAcc(p.origPacket)
func (p *scionPacketProcessor) packSCMPHelper1() (error) {	
	var (
		// (lhalm) following line takes forever #nontermination#
		// scionLayer@ slayers.SCION
		udpLayer@   slayers.UDP
		hbhExtn@    slayers.HopByHopExtn
		e2eExtn@    slayers.EndToEndExtn
		scmpLayer@  slayers.SCMP
	)
	// (lhalm) This also takes forever #nontermination#
	// scionLayer@ := emptySCION()
	
	parser := gopacket.NewDecodingLayerParser(
		0 /* slayers.LayerTypeSCION *//* , &scionLayer */, &udpLayer, &hbhExtn, &e2eExtn, &scmpLayer,
	)
	// (lhalm) takes forever to verify #nontermination#
	// decoded := make([]gopacket.LayerType, 5)
	var decoded@ []gopacket.LayerType
	inhale gopacket.decodedAcc(decoded)
	if err := parser.DecodeLayers(p.origPacket, &decoded); err != nil {
		if _, ok := err.(gopacket.UnsupportedLayerType); !ok {
			return serrors.WrapStr("decoding packet", err)
		}
	}
	// in reply to an SCMP error do nothing:
	// (lhalm) global variable slayers.LayerTypeSCMP not supportet at the moment
	// if decoded[len(decoded)-1] == slayers.LayerTypeSCMP && !scmpLayer.TypeCode.InfoMsg() {
	// 	return processResult{}, serrors.WrapStr("SCMP error for SCMP error pkt -> DROP", cause)
	// }
	return nil
}

// func (p *scionPacketProcessor) currentHopPointer() uint16 {
// 	// return uint16(slayers.CmnHdrLen + p.scionLayer.AddrHdrLen() +
// 	// 	scion.MetaLen + path.InfoLen*p.path.NumINF + path.HopLen*int(p.path.PathMeta.CurrHF))
// }

type processResult struct {
	EgressID uint16
	OutConn  BatchConn
	OutAddr  net.Addr
	OutPkt   []byte
}

type scmpPacker struct {
	internalIP net.IP
	localIA    addr.IA
	origPacket []byte
	ingressID  uint16

	scionL *slayers.SCION
	buffer gopacket.SerializeBuffer
	quote  []byte
}

// (lhalm) Interestingly I still have to call it pathVar rather than path when I make it a ghost parameter
// renaming to path causes a "Logic Error: ghost type on unsafe node" exception
requires acc(pathVar)
requires acc(s.scionL)
requires scmpP.Mem()
requires scmpH.Mem()
requires slayers.InvariantSCION(*s.scionL)
requires gopacket.bytesAcc(s.scionL.EmbeddedLayer.Contents)
requires typeOf(s.scionL.Path) == *scion.Raw
requires pathVar == (s.scionL.Path).(*scion.Raw)
requires s.buffer.Mem()
requires scion.bytesAcc((s.scionL.Path).(*scion.Raw).Raw)
requires gopacket.bytesAcc(s.origPacket)
ensures acc(s.scionL)
ensures scmpP.Mem()
ensures scmpH.Mem()
ensures s.buffer.Mem()
ensures gopacket.bytesAcc(s.origPacket)
ensures acc(pathVar)
ensures err != nil
func (s scmpPacker) prepareSCMP(scmpH *slayers.SCMP, scmpP gopacket.SerializableLayer,
	incPath bool, cause error, ghost pathVar *scion.Raw) ([]byte, err error) {

	// We use the original packet but put the already updated path, because usually a router will
	// not keep a copy of the original/unmodified packet around.

	pathRaw := ((s.scionL.Path).(*scion.Raw)).Raw

	// (lhalm) following block moved to prepareSCMPHelper1 function

	// // (lhalm) create local variable because global ones do not work
	// tmp := gopacket.NilDecodeFeedback{}
	// fold tmp.Mem()
	// // if err := s.scionL.DecodeFromBytes(s.origPacket, gopacket.NilDecodeFeedback); err != nil {
	// // 	panic(err)
	// // }
	// err := s.scionL.DecodeFromBytes(s.origPacket, tmp)
	// if err != nil {
	// 	// (lhalm) causes NodeNotInTree exception
	// 	// panic(err)
	// }
	// // (lhalm) s.scionL.DecodeFromBytes ensures that but is currently not possible due to cyclic import error
	// inhale typeOf(s.scionL.PathVar) == *scion.Raw
	// inhale acc((s.scionL.PathVar).(*scion.Raw))
	s.prepareSCMPHelper1()

	// (lhalm) rename to PathVar
	// path := s.scionL.Path.(*scion.Raw)
	path := (s.scionL.Path).(*scion.Raw)

	path.Raw = pathRaw

	// (lhalm) following block moved to prepareSCMPHelper2 function

	// decPath, err := path.ToDecoded()
	// if err != nil {
	// 	// (lhalm) create local var since global is not supported
	// 	cannotRoute := serrors.New("cannot route, dropping pkt")
	// 	// (lhalm) causes long verification time
	// 	return nil, nil//serrors.Wrap(cannotRoute, err, "details", "decoding raw path")
	// }
	// // (lhalm) rename to PathVar
	// // s.scionL.Path = decPath
	// s.scionL.PathVar = decPath
	// if err := decPath.Reverse(); err != nil {
	// 	// (lhalm) create local var since global is not supported
	// 	cannotRoute := serrors.New("cannot route, dropping pkt")
	// 	// (lhalm) causes long verification time
	// 	return nil, nil //serrors.Wrap(cannotRoute, err, "details", "reversing path for SCMP")
	// }
	decPath, err := s.prepareSCMPHelper2(path)
	if err != nil {
		return nil, err
	}

	// (lhalm) following block moved to prepareSCMPHelper3 function

	// unfold decPath.Mem()
	// // (lhalm) call IsXover on embedded struct since composition is not supported
	// // if incPath || decPath.IsXover() {
	// if incPath || decPath.BaseEmbedded.IsXover() {
	// 	unfold scion.decInfoFieldsAcc(decPath.InfoFields)
	// 	// (lhalm) read PathMeta from embedded since composition is not supported
	// 	//infoField := (decPath.InfoFields)[decPath.PathMeta.CurrINF]
	// 	assert forall i int :: 0 <= i && i < len(decPath.InfoFields) ==> acc(&(decPath.InfoFields)[i]) && acc((decPath.InfoFields)[i])
	// 	assert decPath.BaseEmbedded.PathMeta.CurrINF >= 0
	// 	assert decPath.BaseEmbedded.PathMeta.CurrINF < len(decPath.InfoFields)
	// 	infoField := (decPath.InfoFields)[decPath.BaseEmbedded.PathMeta.CurrINF]
	// 	if infoField.ConsDir {			
	// 		unfold scion.decHopFieldsAcc(decPath.HopFields)
	// 		// (lhalm) read PathMeta from embedded since composition is not supported
	// 		// hopField := decPath.HopFields[decPath.PathMeta.CurrHF]
	// 		hopField := (decPath.HopFields)[decPath.BaseEmbedded.PathMeta.CurrHF]
	// 		infoField.UpdateSegID(hopField.Mac)
	// 	}
	// 	// (lhalm) call IncPath on embedded since composition is not supported
	// 	// if err := decPath.IncPath(); err != nil {
	// 	if err := decPath.BaseEmbedded.IncPath(); err != nil {
	// 		// (lhalm) create local var since global is not supported
	// 		cannotRoute := serrors.New("cannot route, dropping pkt")
	// 		// (lhalm) causes long verification time
	// 		return nil, nil //serrors.Wrap(cannotRoute, err, "details", "incrementing path for SCMP")
	// 	}
	// }
	err = s.prepareSCMPHelper3(decPath, incPath)
	if err != nil {
		return nil, err
	}

	unfold slayers.InvariantSCION(*s.scionL)
	s.scionL.DstIA = s.scionL.SrcIA
	s.scionL.SrcIA = s.localIA
	srcA, err := s.scionL.SrcAddr(1/2)
	if err != nil {
		// (lhalm) create local var since global is not supported
		cannotRoute := serrors.New("cannot route, dropping pkt")
		return nil, serrors.Wrap(cannotRoute, err, "details", "extracting src addr")
	}
	if err := s.scionL.SetDstAddr(srcA); err != nil {
		// (lhalm) create local var since global is not supported
		cannotRoute := serrors.New("cannot route, dropping pkt")
		return nil, serrors.Wrap(cannotRoute, err, "details", "setting dest addr")
	}
	if err := s.scionL.SetSrcAddr(&net.IPAddr{IP: s.internalIP}); err != nil {
		// (lhalm) create local var since global is not supported
		cannotRoute := serrors.New("cannot route, dropping pkt")
		return nil, serrors.Wrap(cannotRoute, err, "details", "setting src addr")
	}
	s.scionL.NextHdr = common.L4SCMP
	fold slayers.InvariantSCION(*s.scionL)
	fold acc(s.scionL.Mem(), 1/2)
	scmpH.SetNetworkLayerForChecksum(s.scionL)
	unfold acc(s.scionL.Mem(), 1/2)

	if err := s.buffer.Clear(); err != nil {
		return nil, err
	}

	// (lhalm) following block moved to the prepareSCMPHelper4 function

	// sopts := gopacket.SerializeOptions{
	// 	ComputeChecksums: true,
	// 	FixLengths:       true,
	// }
	// scmpLayers := []gopacket.SerializableLayer{s.scionL ,scmpH, scmpP}
	// if cause != nil {
	// 	fold s.scionL.PathVar.Mem()
	// 	// add quote for errors.
	// 	// (lhalm) rename to PathVar
	// 	// hdrLen := slayers.CmnHdrLen + s.scionL.AddrHdrLen() + s.scionL.Path.Len()
	// 	hdrLen := slayers.CmnHdrLen + s.scionL.AddrHdrLen() + s.scionL.PathVar.Len()
	// 	switch scmpH.TypeCode.Type() {
	// 	case slayers.SCMPTypeExternalInterfaceDown:
	// 		hdrLen += 20
	// 	case slayers.SCMPTypeInternalConnectivityDown:
	// 		hdrLen += 28
	// 	default:
	// 		hdrLen += 8
	// 	}
	// 	maxQuoteLen := slayers.MaxSCMPPacketLen - hdrLen
	// 	if len(s.quote) > maxQuoteLen {
	// 		s.quote = (s.quote)[:maxQuoteLen]
	// 	}
	// 	// (lhalm) implementation proof for type alias []byte currently not possible
	// 	// scmpLayers = append(scmpLayers, gopacket.Payload(s.quote))
	// }
	// (lhalm) depends on line 855
	// err = nil //gopacket.SerializeLayers(s.buffer, sopts, scmpLayers...)
	// if err != nil {
	// 	// (lhalm) create local var since global is not supported
	// 	cannotRoute := serrors.New("cannot route, dropping pkt")
	// 	// (lhalm) causes long verification time
	// 	return nil, nil //serrors.Wrap(cannotRoute, err, "details", "serializing SCMP message")
	// }
	err = s.prepareSCMPHelper4(cause, scmpH, scmpP)
	if err != nil {
		return nil, err
	}
	unfold scmpH.Mem()
	assert acc(scmpH)
	assert acc(&scmpH.TypeCode)
	// (lhalm) create error to allow predicate folding
	err = scmpError{TypeCode: scmpH.TypeCode, Cause: cause}
	fold scmpH.Mem()
	return s.buffer.Bytes(), err
	// return s.buffer.Bytes(), scmpError{TypeCode: scmpH.TypeCode, Cause: cause}
}

preserves acc(s.scionL)
preserves gopacket.bytesAcc(s.origPacket)
preserves slayers.InvariantSCION(*s.scionL)
preserves gopacket.bytesAcc(s.scionL.EmbeddedLayer.Contents)
ensures typeOf(s.scionL.Path) == *scion.Raw
ensures acc((s.scionL.Path).(*scion.Raw))
ensures scion.bytesAcc((s.scionL.Path).(*scion.Raw).Raw)
func (s scmpPacker) prepareSCMPHelper1() {
	// (lhalm) create local variable because global ones do not work
	tmp := gopacket.NilDecodeFeedback{}
	fold tmp.Mem()
	// if err := s.scionL.DecodeFromBytes(s.origPacket, gopacket.NilDecodeFeedback); err != nil {
	// 	panic(err)
	// }
	// unfold slayers.InvariantSCION(s.scionL)
	err := s.scionL.DecodeFromBytes(s.origPacket, tmp)
	if err != nil {
		// (lhalm) causes NodeNotInTree exception
		// panic(err)
	}
	// (lhalm) s.scionL.DecodeFromBytes ensures that but is currently not possible due to cyclic import error
	inhale typeOf(s.scionL.Path) == *scion.Raw
	inhale acc((s.scionL.Path).(*scion.Raw))
	inhale scion.bytesAcc((s.scionL.Path).(*scion.Raw).Raw)
}

preserves acc(path)
preserves scion.bytesAcc(path.Raw)
requires acc(s.scionL)
requires gopacket.bytesAcc(s.scionL.EmbeddedLayer.Contents)
requires slayers.InvariantSCION(*s.scionL)
requires typeOf(s.scionL.Path) == *scion.Raw
ensures acc(s.scionL)
ensures gopacket.bytesAcc(s.scionL.EmbeddedLayer.Contents)
ensures slayers.InvariantSCION(*s.scionL)
ensures err == nil ==> typeOf(s.scionL.Path) == *scion.Decoded
ensures err == nil ==> acc((s.scionL.Path).(*scion.Decoded))
ensures err == nil ==> ((s.scionL.Path).(*scion.Decoded)).Mem()
ensures err == nil ==> ((s.scionL.Path).(*scion.Decoded)) == decPath
func (s scmpPacker) prepareSCMPHelper2(path *scion.Raw) (decPath *scion.Decoded, err error) {
	decPath, err := path.ToDecoded()
	if err != nil {
		// (lhalm) create local var since global is not supported
		cannotRoute := serrors.New("cannot route, dropping pkt")
		// return nil, serrors.Wrap(cannotRoute, err, "details", "decoding raw path")
		return nil, serrors.Wrap(cannotRoute, err, "details", "decoding raw path")
	}
	unfold slayers.InvariantSCION(*s.scionL)
	// (lhalm) rename to PathVar
	// s.scionL.Path = decPath
	s.scionL.Path = decPath
	fold slayers.InvariantSCION(*s.scionL)
	if err := decPath.Reverse(); err != nil {
		// (lhalm) create local var since global is not supported
		cannotRoute := serrors.New("cannot route, dropping pkt")
		//return nil, serrors.Wrap(cannotRoute, err, "details", "reversing path for SCMP")
		return nil, serrors.Wrap(cannotRoute, err, "details", "reversing path for SCMP")
	}
	return decPath, nil
}

preserves acc(s.scionL)
preserves gopacket.bytesAcc(s.scionL.EmbeddedLayer.Contents)
preserves typeOf(s.scionL.Path) == *scion.Decoded
preserves ((s.scionL.Path).(*scion.Decoded)).Mem()
preserves slayers.InvariantSCION(*s.scionL)
preserves decPath == (s.scionL.Path).(*scion.Decoded)
func (s scmpPacker) prepareSCMPHelper3(decPath *scion.Decoded, incPath bool) (error){
	unfold decPath.Mem()
	// (lhalm) call IsXover on embedded struct since composition is not supported
	// if incPath || decPath.IsXover() {
	if incPath || decPath.BaseEmbedded.IsXover() {
	// 	(lhalm) following code moved to prepareSCMPHelper5 function
	// 	unfold scion.decInfoFieldsAcc(decPath.InfoFields)
	// 	(lhalm) read PathMeta from embedded since composition is not supported
	// 	infoField := (decPath.InfoFields)[decPath.PathMeta.CurrINF]
	// 	infoField := (decPath.InfoFields)[decPath.BaseEmbedded.PathMeta.CurrINF]
	// 	if infoField.ConsDir {			
	// 		// unfold scion.decHopFieldsAcc(decPath.HopFields)
	// 		// // (lhalm) read PathMeta from embedded since composition is not supported
	// 		// // hopField := decPath.HopFields[decPath.PathMeta.CurrHF]
	// 		// hopField := (decPath.HopFields)[decPath.BaseEmbedded.PathMeta.CurrHF]
	// 		// infoField.UpdateSegID(hopField.Mac)
	// 		fold scion.decHopFieldsAcc(decPath.HopFields)
	// 	}
	// 	fold scion.decInfoFieldsAcc(decPath.InfoFields)
	// 	// (lhalm) call IncPath on embedded since composition is not supported
	// 	// if err := decPath.IncPath(); err != nil {
	// 	if err := decPath.BaseEmbedded.IncPath(); err != nil {
	// 		// (lhalm) create local var since global is not supported
	// 		cannotRoute := serrors.New("cannot route, dropping pkt")
	// 		fold decPath.Mem()
	// 		//return nil, serrors.Wrap(cannotRoute, err, "details", "incrementing path for SCMP")
	// 		return serrors.Wrap(cannotRoute, err, "details", "incrementing path for SCMP")
	// }
		fold DecodedIndexInvariants(*decPath)
		s.prepareSCMPHelper5(decPath)
		unfold DecodedIndexInvariants(*decPath)
	}
	fold decPath.Mem()
	return nil
}

// (lhalm) Funny, if both the body of this function and the call are uncommented, it takes forever to verify.
// uncommenting one of those things decreases verification time to about 2 minutes. #nontermination#
preserves acc(decPath)
preserves scion.decInfoFieldsAcc(decPath.InfoFields)
preserves scion.decHopFieldsAcc(decPath.HopFields)
preserves DecodedIndexInvariants(*decPath)
ensures decPath.BaseEmbedded.NumINF == old(decPath.BaseEmbedded.NumINF)
ensures decPath.BaseEmbedded.NumHops == old(decPath.BaseEmbedded.NumHops)
ensures len(decPath.InfoFields) == old(len(decPath.InfoFields))
ensures len(decPath.HopFields) == old(len(decPath.HopFields))
func (s scmpPacker) prepareSCMPHelper5(decPath *scion.Decoded) error //{
// 	unfold DecodedIndexInvariants(*decPath)
// 	unfold scion.decInfoFieldsAcc(decPath.InfoFields)
// 	// (lhalm) read PathMeta from embedded since composition is not supported
// 	// infoField := (decPath.InfoFields)[decPath.PathMeta.CurrINF]
// 	infoField := (decPath.InfoFields)[decPath.BaseEmbedded.PathMeta.CurrINF]
// 	// (lhalm) following block moved to prepareSCMPHelper5 function
// 	// if infoField.ConsDir {			
// 		// unfold scion.decHopFieldsAcc(decPath.HopFields)
// 		// // (lhalm) read PathMeta from embedded since composition is not supported
// 		// // hopField := decPath.HopFields[decPath.PathMeta.CurrHF]
// 		// hopField := (decPath.HopFields)[decPath.BaseEmbedded.PathMeta.CurrHF]
// 		// infoField.UpdateSegID(hopField.Mac)
// 	// 	fold scion.decHopFieldsAcc(decPath.HopFields)
// 	// }
// 	fold DecodedIndexInvariants(*decPath)
// 	s.prepareSCMPHelper6(infoField, decPath)
// 	fold scion.decInfoFieldsAcc(decPath.InfoFields)
// 	unfold DecodedIndexInvariants(*decPath)
// 	// (lhalm) call IncPath on embedded since composition is not supported
// 	// if err := decPath.IncPath(); err != nil {
// 	if err := decPath.BaseEmbedded.IncPath(); err != nil {
// 		fold DecodedIndexInvariants(*decPath)
// 		// (lhalm) create local var since global is not supported
// 		cannotRoute := serrors.New("cannot route, dropping pkt")
// 		//return nil, serrors.Wrap(cannotRoute, err, "details", "incrementing path for SCMP")
// 		return serrors.Wrap(cannotRoute, err, "details", "incrementing path for SCMP")
// 	}
// 	fold DecodedIndexInvariants(*decPath)
// 	return nil
// }

preserves acc(infoField)
preserves acc(decPath, 1/2)
preserves scion.decHopFieldsAcc(decPath.HopFields)
preserves DecodedIndexInvariants(*decPath)
func (s scmpPacker) prepareSCMPHelper6(infoField *path.InfoField, decPath *scion.Decoded) {
	if infoField.ConsDir {			
		unfold scion.decHopFieldsAcc(decPath.HopFields)
		unfold DecodedIndexInvariants(*decPath)
		// (lhalm) read PathMeta from embedded since composition is not supported
		// hopField := decPath.HopFields[decPath.PathMeta.CurrHF]
		hopField := (decPath.HopFields)[decPath.BaseEmbedded.PathMeta.CurrHF]
		infoField.UpdateSegID(hopField.Mac)
		fold DecodedIndexInvariants(*decPath)
		fold scion.decHopFieldsAcc(decPath.HopFields)
	}
}

preserves acc(s.scionL)
preserves slayers.InvariantSCION(*s.scionL)
preserves s.scionL.Path.Mem()
preserves scmpH.Mem()
preserves scmpP.Mem()
preserves gopacket.bytesAcc(s.scionL.EmbeddedLayer.Contents)
preserves typeOf(s.scionL.Path) == *scion.Decoded
preserves acc((s.scionL.Path).(*scion.Decoded))
func (s scmpPacker) prepareSCMPHelper4(cause error, scmpH *slayers.SCMP, scmpP gopacket.SerializableLayer) error {
	sopts := gopacket.SerializeOptions{
		ComputeChecksums: true,
		FixLengths:       true,
	}
	unfold scmpH.Mem()
	scmpLayers := []gopacket.SerializableLayer{s.scionL ,scmpH, scmpP}
	if cause != nil {
		// add quote for errors.
		hdrLen := slayers.CmnHdrLen + s.scionL.AddrHdrLen() + s.scionL.Path.Len()
		switch scmpH.TypeCode.Type() {
		case slayers.SCMPTypeExternalInterfaceDown:
			hdrLen += 20
		case slayers.SCMPTypeInternalConnectivityDown:
			hdrLen += 28
		default:
			hdrLen += 8
		}
		maxQuoteLen := slayers.MaxSCMPPacketLen - hdrLen
		// if len(s.quote) > maxQuoteLen {
		// 	s.quote = (s.quote)[:maxQuoteLen]
		// }
		// (lhalm) implementation proof for Payload(s.quote) currently throws None.get
		// scmpLayers = append(scmpLayers, gopacket.Payload(s.quote))
	}
	fold s.scionL.Mem()
	fold scmpH.Mem()
	assert len(scmpLayers) == 3
	assert scmpLayers[0].Mem()
	assert scmpLayers[1].Mem()
	assert scmpLayers[2].Mem()
	// assert forall i int :: 0 <= i && i < len(scmpLayers) ==> acc(&scmpLayers[i]) && (scmpLayers[i]).Mem()

	// (lhalm) throws "might not be injective" error
	//err := gopacket.SerializeLayers(s.buffer, sopts, scmpLayers...)
	unfold s.scionL.Mem()
	var err error
	if err != nil {
		// (lhalm) create local var since global is not supported
		cannotRoute := serrors.New("cannot route, dropping pkt")
		return serrors.Wrap(cannotRoute, err, "details", "serializing SCMP message")
	}
}

preserves buffer.Mem()
// preserves forall i int :: 0 <= i && i < len(rawPkt) ==> acc(&rawPkt[i])
preserves scion.bytesAcc(rawPkt)
preserves acc(s, 3/4)
preserves slayers.InvariantSCION(*s)
preserves gopacket.bytesAcc(s.EmbeddedLayer.Contents)
// (lhalm) make s pointer type such that Gobra realises that SerializeTo is a valid method.
func updateSCIONLayer(rawPkt []byte, s *slayers.SCION, buffer gopacket.SerializeBuffer) error {
	if err := buffer.Clear(); err != nil {
		return err
	}
	if err := s.SerializeTo(buffer, gopacket.SerializeOptions{}); err != nil {
		return err
	}
	// TODO(lukedirtwalker): We should add a method to the scion layers
	// which can write into the existing buffer, see also the discussion in
	// https://fsnets.slack.com/archives/C8ADBBG0J/p1592805884250700
	rawContents := buffer.Bytes()
	// (lhalm) don't exactly know why this does not work
	// copy(rawPkt[:len(rawContents)], rawContents)
	return nil
}

/*func (p *scionPacketProcessor) packSCMP(scmpH *slayers.SCMP, scmpP gopacket.SerializableLayer,
	cause error) (processResult, error) {

	// parse everything to see if the original packet was an SCMP error.
	var (
		scionLayer slayers.SCION
		udpLayer   slayers.UDP
		hbhExtn    slayers.HopByHopExtn
		e2eExtn    slayers.EndToEndExtn
		scmpLayer  slayers.SCMP
	)
	parser := gopacket.NewDecodingLayerParser(
		slayers.LayerTypeSCION, &scionLayer, &udpLayer, &hbhExtn, &e2eExtn, &scmpLayer,
	)
	decoded := make([]gopacket.LayerType, 5)
	if err := parser.DecodeLayers(p.origPacket, &decoded); err != nil {
		if _, ok := err.(gopacket.UnsupportedLayerType); !ok {
			return processResult{}, serrors.WrapStr("decoding packet", err)
		}
	}
	// in reply to an SCMP error do nothing:
	if decoded[len(decoded)-1] == slayers.LayerTypeSCMP && !scmpLayer.TypeCode.InfoMsg() {
		return processResult{}, serrors.WrapStr("SCMP error for SCMP error pkt -> DROP", cause)
	}

	// the quoted packet is the packet in its current state
	if err := p.path.SetInfoField(p.infoField, int(p.path.PathMeta.CurrINF)); err != nil {
		return processResult{}, serrors.WrapStr("update info field", err)
	}
	if err := p.path.SetHopField(p.hopField, int(p.path.PathMeta.CurrHF)); err != nil {
		return processResult{}, serrors.WrapStr("update hop field", err)
	}
	if err := p.buffer.Clear(); err != nil {
		return processResult{}, err
	}
	if err := p.scionLayer.SerializeTo(p.buffer, gopacket.SerializeOptions{}); err != nil {
		return processResult{}, err
	}
	// quoteLen is used to limit the size of the quote buffer, the final quote
	// length is calculated inside the scmpPacker.
	quoteLen := len(p.origPacket)
	if quoteLen > slayers.MaxSCMPPacketLen {
		quoteLen = slayers.MaxSCMPPacketLen
	}
	quote := make([]byte, quoteLen)
	updated := p.buffer.Bytes()
	copy(quote[:len(updated)], updated)
	copy(quote[len(updated):], p.origPacket[len(updated):quoteLen])

	_, external := p.d.external[p.ingressID]
	rawSCMP, err := scmpPacker{
		internalIP: p.d.internalIP,
		localIA:    p.d.localIA,
		origPacket: p.origPacket,
		ingressID:  p.ingressID,
		scionL:     &p.scionLayer,
		buffer:     p.buffer,
		quote:      quote,
	}.prepareSCMP(
		scmpH,
		scmpP,
		external,
		cause,
	)
	return processResult{OutPkt: rawSCMP}, err
}

func (p *scionPacketProcessor) parsePath() (processResult, error) {
	var ok bool
	p.path, ok = p.scionLayer.Path.(*scion.Raw)
	if !ok {
		// TODO(lukedirtwalker) parameter problem invalid path?
		return processResult{}, malformedPath
	}
	var err error
	p.hopField, err = p.path.GetCurrentHopField()
	if err != nil {
		// TODO(lukedirtwalker) parameter problem invalid path?
		return processResult{}, err
	}
	p.infoField, err = p.path.GetCurrentInfoField()
	if err != nil {
		// TODO(lukedirtwalker) parameter problem invalid path?
		return processResult{}, err
	}
	if r, err := p.validateHopExpiry(); err != nil {
		return r, err
	}
	if r, err := p.validateIngressID(); err != nil {
		return r, err
	}
	return processResult{}, nil
}

func (p *scionPacketProcessor) validateHopExpiry() (processResult, error) {
	expiration := util.SecsToTime(p.infoField.Timestamp).
		Add(path.ExpTimeToDuration(p.hopField.ExpTime))
	expired := expiration.Before(time.Now())
	if !expired {
		return processResult{}, nil
	}
	return p.packSCMP(
		&slayers.SCMP{TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeParameterProblem,
			slayers.SCMPCodePathExpired),
		},
		&slayers.SCMPParameterProblem{Pointer: p.currentHopPointer()},
		serrors.New("expired hop", "cons_dir", p.infoField.ConsDir, "if_id", p.ingressID,
			"curr_inf", p.path.PathMeta.CurrINF, "curr_hf", p.path.PathMeta.CurrHF),
	)
}

func (p *scionPacketProcessor) validateIngressID() (processResult, error) {
	pktIngressID := p.hopField.ConsIngress
	errCode := slayers.SCMPCodeUnknownHopFieldIngress
	if !p.infoField.ConsDir {
		pktIngressID = p.hopField.ConsEgress
		errCode = slayers.SCMPCodeUnknownHopFieldEgress
	}
	if p.ingressID != 0 && p.ingressID != pktIngressID {
		return p.packSCMP(
			&slayers.SCMP{
				TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeParameterProblem, errCode),
			},
			&slayers.SCMPParameterProblem{Pointer: p.currentHopPointer()},
			serrors.New("ingress interface invalid",
				"pkt_ingress", pktIngressID, "router_ingress", p.ingressID),
		)
	}
	return processResult{}, nil
}

func (p *scionPacketProcessor) validateEgressID() (processResult, error) {
	pktEgressID := p.egressInterface()
	_, ih := p.d.internalNextHops[pktEgressID]
	_, eh := p.d.external[pktEgressID]
	if !ih && !eh {
		errCode := slayers.SCMPCodeUnknownHopFieldEgress
		if !p.infoField.ConsDir {
			errCode = slayers.SCMPCodeUnknownHopFieldIngress
		}
		return p.packSCMP(
			&slayers.SCMP{
				TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeParameterProblem, errCode),
			},
			&slayers.SCMPParameterProblem{Pointer: p.currentHopPointer()},
			cannotRoute,
		)
	}

	if !p.segmentChange {
		return processResult{}, nil
	}
	// Check that the interface pair is valid on a segment switch.
	// Having a segment change received from the internal interface is never valid.
	ingress, egress := p.d.linkTypes[p.ingressID], p.d.linkTypes[pktEgressID]
	switch {
	case ingress == topology.Core && egress == topology.Child:
		return processResult{}, nil
	case ingress == topology.Child && egress == topology.Core:
		return processResult{}, nil
	case ingress == topology.Child && egress == topology.Child:
		return processResult{}, nil
	default:
		return p.packSCMP(
			&slayers.SCMP{
				TypeCode: slayers.CreateSCMPTypeCode(
					slayers.SCMPTypeParameterProblem,
					slayers.SCMPCodeInvalidSegmentChange,
				),
			},
			&slayers.SCMPParameterProblem{Pointer: p.currentInfoPointer()},
			serrors.WithCtx(cannotRoute, "ingress_id", p.ingressID, "ingress_type", ingress,
				"egress_id", pktEgressID, "egress_type", egress))
	}
}

func (p *scionPacketProcessor) updateNonConsDirIngressSegID() error {
	// against construction dir the ingress router updates the SegID, ifID == 0
	// means this comes from this AS itself, so nothing has to be done.
	// TODO(lukedirtwalker): For packets destined to peer links this shouldn't
	// be updated.
	if !p.infoField.ConsDir && p.ingressID != 0 {
		p.infoField.UpdateSegID(p.hopField.Mac)
		if err := p.path.SetInfoField(p.infoField, int(p.path.PathMeta.CurrINF)); err != nil {
			return serrors.WrapStr("update info field", err)
		}
		if err := updateSCIONLayer(p.rawPkt, p.scionLayer, p.buffer); err != nil {
			return err
		}
	}
	return nil
}

func (p *scionPacketProcessor) currentInfoPointer() uint16 {
	return uint16(slayers.CmnHdrLen + p.scionLayer.AddrHdrLen() +
		scion.MetaLen + path.InfoLen*int(p.path.PathMeta.CurrINF))
}

func (p *scionPacketProcessor) currentHopPointer() uint16 {
	return uint16(slayers.CmnHdrLen + p.scionLayer.AddrHdrLen() +
		scion.MetaLen + path.InfoLen*p.path.NumINF + path.HopLen*int(p.path.PathMeta.CurrHF))
}

func (p *scionPacketProcessor) verifyCurrentMAC() (processResult, error) {
	if err := path.VerifyMAC(p.d.macFactory(), p.infoField, p.hopField); err != nil {
		return p.packSCMP(
			&slayers.SCMP{TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeParameterProblem,
				slayers.SCMPCodeInvalidHopFieldMAC),
			},
			&slayers.SCMPParameterProblem{Pointer: p.currentHopPointer()},
			serrors.WithCtx(err, "cons_dir", p.infoField.ConsDir, "if_id", p.ingressID,
				"curr_inf", p.path.PathMeta.CurrINF, "curr_hf", p.path.PathMeta.CurrHF,
				"seg_id", p.infoField.SegID),
		)
	}
	return processResult{}, nil
}

func (p *scionPacketProcessor) resolveInbound() (net.Addr, processResult, error) {
	a, err := p.d.resolveLocalDst(p.scionLayer)
	switch {
	case errors.Is(err, noSVCBackend):
		r, err := p.packSCMP(
			&slayers.SCMP{
				TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeDestinationUnreachable,
					slayers.SCMPCodeNoRoute),
			},
			&slayers.SCMPDestinationUnreachable{}, err)
		return nil, r, err
	default:
		return a, processResult{}, nil
	}
}

func (p *scionPacketProcessor) processEgress() error {
	// we are the egress router and if we go in construction direction we
	// need to update the SegID.
	if p.infoField.ConsDir {
		p.infoField.UpdateSegID(p.hopField.Mac)
		if err := p.path.SetInfoField(p.infoField, int(p.path.PathMeta.CurrINF)); err != nil {
			// TODO parameter problem invalid path
			return serrors.WrapStr("update info field", err)
		}
	}
	if err := p.path.IncPath(); err != nil {
		// TODO parameter problem invalid path
		return serrors.WrapStr("incrementing path", err)
	}
	if err := updateSCIONLayer(p.rawPkt, p.scionLayer, p.buffer); err != nil {
		return err
	}
	return nil
}

func (p *scionPacketProcessor) doXover() (processResult, error) {
	p.segmentChange = true
	if err := p.path.IncPath(); err != nil {
		// TODO parameter problem invalid path
		return processResult{}, serrors.WrapStr("incrementing path", err)
	}
	var err error
	if p.hopField, err = p.path.GetCurrentHopField(); err != nil {
		// TODO parameter problem invalid path
		return processResult{}, err
	}
	if p.infoField, err = p.path.GetCurrentInfoField(); err != nil {
		// TODO parameter problem invalid path
		return processResult{}, err
	}
	if err := updateSCIONLayer(p.rawPkt, p.scionLayer, p.buffer); err != nil {
		return processResult{}, err
	}
	if r, err := p.validateHopExpiry(); err != nil {
		return r, err
	}
	// verify the new block
	if r, err := p.verifyCurrentMAC(); err != nil {
		return r, serrors.WithCtx(err, "info", "after xover")
	}
	return processResult{}, nil
}

func (p *scionPacketProcessor) egressInterface() uint16 {
	if p.infoField.ConsDir {
		return p.hopField.ConsEgress
	}
	return p.hopField.ConsIngress
}

func (p *scionPacketProcessor) validateEgressUp() (processResult, error) {
	egressID := p.egressInterface()
	if v, ok := p.d.bfdSessions[egressID]; ok {
		if !v.IsUp() {
			scmpH := &slayers.SCMP{
				TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeExternalInterfaceDown, 0),
			}
			var scmpP gopacket.SerializableLayer = &slayers.SCMPExternalInterfaceDown{
				IA:   p.d.localIA,
				IfID: uint64(egressID),
			}
			if _, external := p.d.external[egressID]; !external {
				scmpH.TypeCode =
					slayers.CreateSCMPTypeCode(slayers.SCMPTypeInternalConnectivityDown, 0)
				scmpP = &slayers.SCMPInternalConnectivityDown{
					IA:      p.d.localIA,
					Ingress: uint64(p.ingressID),
					Egress:  uint64(egressID),
				}
			}
			return p.packSCMP(scmpH, scmpP, serrors.New("bfd session down"))
		}
	}
	return processResult{}, nil
}

func (p *scionPacketProcessor) handleIngressRouterAlert() (processResult, error) {
	if p.ingressID == 0 {
		return processResult{}, nil
	}
	ingressAlert := (!p.infoField.ConsDir && p.hopField.EgressRouterAlert) ||
		(p.infoField.ConsDir && p.hopField.IngressRouterAlert)
	if !ingressAlert {
		return processResult{}, nil
	}
	p.hopField.IngressRouterAlert = false
	return p.handleSCMPTraceRouteRequest(p.ingressID)
}

func (p *scionPacketProcessor) handleEgressRouterAlert() (processResult, error) {
	egressAlert := (p.infoField.ConsDir && p.hopField.EgressRouterAlert) ||
		(!p.infoField.ConsDir && p.hopField.IngressRouterAlert)
	if !egressAlert {
		return processResult{}, nil
	}
	egressID := p.egressInterface()
	if _, ok := p.d.external[egressID]; !ok {
		return processResult{}, nil
	}
	p.hopField.EgressRouterAlert = false
	return p.handleSCMPTraceRouteRequest(egressID)
}

func (p *scionPacketProcessor) handleSCMPTraceRouteRequest(
	interfaceID uint16) (processResult, error) {

	var scmpH slayers.SCMP
	if err := scmpH.DecodeFromBytes(p.scionLayer.Payload, gopacket.NilDecodeFeedback); err != nil {
		log.Debug("Parsing SCMP header of router alert", "err", err)
		return processResult{}, nil
	}
	if scmpH.TypeCode != slayers.CreateSCMPTypeCode(slayers.SCMPTypeTracerouteRequest, 0) {
		log.Debug("Packet with router alert, but not traceroute request",
			"type_code", scmpH.TypeCode)
		return processResult{}, nil
	}
	var scmpP slayers.SCMPTraceroute
	if err := scmpP.DecodeFromBytes(scmpH.Payload, gopacket.NilDecodeFeedback); err != nil {
		log.Debug("Parsing SCMPTraceroute", "err", err)
		return processResult{}, nil
	}
	scmpH = slayers.SCMP{
		TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeTracerouteReply, 0),
	}
	scmpP = slayers.SCMPTraceroute{
		Identifier: scmpP.Identifier,
		Sequence:   scmpP.Sequence,
		IA:         p.d.localIA,
		Interface:  uint64(interfaceID),
	}
	return p.packSCMP(&scmpH, &scmpP, nil)
}

func (p *scionPacketProcessor) validatePktLen() (processResult, error) {
	if int(p.scionLayer.PayloadLen) == len(p.scionLayer.Payload) {
		return processResult{}, nil
	}
	return p.packSCMP(
		&slayers.SCMP{
			TypeCode: slayers.CreateSCMPTypeCode(slayers.SCMPTypeParameterProblem,
				slayers.SCMPCodeInvalidPacketSize),
		},
		&slayers.SCMPParameterProblem{Pointer: 0},
		serrors.New("bad packet size",
			"header", p.scionLayer.PayloadLen, "actual", len(p.scionLayer.Payload)),
	)
}*/