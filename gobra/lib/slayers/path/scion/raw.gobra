// Copyright 2020 Anapaya Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package scion

import (
	"gobra/lib/serrors"
	"gobra/lib/slayers/path"
	"gobra/lib/slayers" // (lhalm) required for interface implementation proof
)

pred (r *Raw) Mem() {
	acc(&r.Raw) &&
	acc(&r.BaseEmbedded) && 
	bytesAcc(r.Raw)
	//forall i int :: 0 <= i && i < len(r.Raw) ==> acc(&(r.Raw)[i])
}
(*Raw) implements slayers.Path {

	(r *Raw) SerializeTo(b []byte) (err error) {
		unfold r.Mem()
		err = r.SerializeTo(b)
		fold r.Mem()
	}

	(r *Raw) DecodeFromBytes(b []byte) (err error) {
		unfold r.Mem()
		err = r.DecodeFromBytes(b)
		fold r.Mem()
	}
	
	(r *Raw) Reverse() (err error) {
		unfold r.Mem()
		err = r.Reverse()
		fold r.Mem()
	}
	
	(r *Raw) Len() (l int) {
		unfold r.Mem()
		l = r.Len()
		fold r.Mem()
	}
}

pred bytesAcc(data []byte) {
	forall i int :: 0 <= i && i < len(data) ==> acc(&data[i])
}

// Raw is a raw representation of the SCION (data-plane) path type. It is designed to parse as
// little as possible and should be used if performance matters.
type Raw struct {
	// (lhalm) named the composite structure beacause composition does not seem to be supported
	BaseEmbedded Base // Base
	Raw []byte
}

// (lhalm) function added as a workaround because interface composition does not seem to be supported yet
requires acc(&s.BaseEmbedded)
ensures acc(&s.BaseEmbedded)
func (s *Raw) Len() int {
	return s.BaseEmbedded.Len()
}

// DecodeFromBytes only decodes the PathMetaHeader. Otherwise the nothing is decoded and simply kept
// as raw bytes.
requires acc(&s.Raw)
requires acc(&s.BaseEmbedded)
requires bytesAcc(s.Raw)
requires forall i int :: 0 <= i && i < len(data) ==> acc(&data[i])
ensures acc(&s.Raw)
ensures acc(&s.BaseEmbedded)
ensures bytesAcc(s.Raw)
ensures forall i int :: 0 <= i && i < len(data) ==> acc(&data[i])
func (s *Raw) DecodeFromBytes(data []byte) error {
// 	if err := s.Base.DecodeFromBytes(data); err != nil {
// 		return err
// 	}
// 	pathLen := s.Len()
// 	if len(data) < pathLen {
// 		return serrors.New("RawPath raw too short", "expected", pathLen, "actual", len(data))
// 	}
// 	s.Raw = data[:pathLen]
// 	return nil
}

// SerializeTo writes the path to a slice. The slice must be big enough to hold the entire data,
// otherwise an error is returned.
requires acc(&s.BaseEmbedded.PathMeta)
requires forall i int :: 0 <= i && i < len(b) ==> acc(&b[i])
ensures acc(&s.BaseEmbedded.PathMeta)
ensures forall i int :: 0 <= i && i < len(b) ==> acc(&b[i])
func (s *Raw) SerializeTo(b []byte) error {
// 	if s.Raw == nil {
// 		return serrors.New("raw is nil")
// 	}
// 	if minLen := s.Len(); len(b) < minLen {
// 		return serrors.New("buffer too small", "expected", minLen, "actual", len(b))
// 	}
// 	// XXX(roosd): This modifies the underlying buffer. Consider writing to data
// 	// directly.
// 	if err := s.PathMeta.SerializeTo((s.Raw)[:MetaLen]); err != nil {
// 		return err
// 	}
// 	copy(b, s.Raw)
// 	return nil
}

// Reverse reverses the path such that it can be used in the reverse direction.
requires acc(&s.Raw)
requires bytesAcc(s.Raw)
ensures acc(&s.Raw)
ensures bytesAcc(s.Raw)
func (s *Raw) Reverse() error {
// 	// XXX(shitz): The current implementation is not the most performant, since it parses the entire
// 	// path first. If this becomes a performance bottleneck, the implementation should be changed to
// 	// work directly on the raw representation.

// 	decoded, err := s.ToDecoded()
// 	if err != nil {
// 		return err
// 	}
// 	if err := decoded.Reverse(); err != nil {
// 		return err
// 	}
// 	if err := decoded.SerializeTo(s.Raw); err != nil {
// 		return err
// 	}
// 	return s.DecodeFromBytes(s.Raw)
}

// ToDecoded transforms a scion.Raw to a scion.Decoded.
requires acc(&s.Raw)
requires bytesAcc(s.Raw)
ensures acc(&s.Raw)
ensures bytesAcc(s.Raw)
ensures err == nil ==> acc(decoded)
ensures err == nil ==> decoded.Mem()
func (s *Raw) ToDecoded() (decoded *Decoded, err error) //{
// 	// Serialize PathMeta to ensure potential changes are reflected Raw.
// 	if err := s.PathMeta.SerializeTo((s.Raw)[:MetaLen]); err != nil {
// 		return nil, err
// 	}
// 	decoded := &Decoded{}
// 	if err := decoded.DecodeFromBytes(s.Raw); err != nil {
// 		return nil, err
// 	}
// 	return decoded, nil
//}

pred infoFieldAcc(b []byte, idx int, p perm) {
	p > 0 && p <= 1 &&
	//acc(s, p) &&
	idx >= 0 &&
	//(MetaLen + idx*path.InfoLen)+path.InfoLen < len(s.Raw) &&
	(MetaLen + idx*path.InfoLen)+path.InfoLen < len(b) &&
	forall i int :: 0 <= i && i < len(b) ==> acc(&b[i], p)
}

pred hopFieldAcc(b []byte, idx int, numINF int, p perm) {
	p > 0 && p <= 1 &&
	// acc(s, p) &&
	// (MetaLen + s.BaseEmbedded.NumINF*path.InfoLen + idx*path.HopLen) >= 0 &&
	// (MetaLen + s.BaseEmbedded.NumINF*path.InfoLen + idx*path.HopLen) + path.HopLen < len(s.Raw) &&
	(MetaLen + numINF*path.InfoLen + idx*path.HopLen) >= 0 &&
	(MetaLen + numINF*path.InfoLen + idx*path.HopLen) + path.HopLen < len(b) &&
	forall i int :: 0 <= i && i < len(b) ==> acc(&b[i], p)
}

// GetInfoField returns the InfoField at a given index.
requires p > 0 && p <= 1
requires acc(s, p)
requires infoFieldAcc(s.Raw, idx, p)
ensures acc(s, p)
ensures infoFieldAcc(s.Raw, idx, p)
ensures s.BaseEmbedded.PathMeta.CurrINF == old(s.BaseEmbedded.PathMeta.CurrINF)
ensures err == nil ==> infoField != nil && acc(infoField)
func (s *Raw) GetInfoField(idx int, ghost p perm) (infoField *path.InfoField, err error) {
	unfold infoFieldAcc(s.Raw, idx, p)
	if idx >= s.BaseEmbedded.NumINF {
		// (lhalm) create error first to allow folding of the predicate
		err := serrors.New("InfoField index out of bounds", "max", s.BaseEmbedded.NumINF-1, "actual", idx)
		fold infoFieldAcc(s.Raw, idx, p)
		return nil, err
		//return nil, serrors.New("InfoField index out of bounds", "max", s.BaseEmbedded.NumINF-1, "actual", idx)
	}
	infOffset := MetaLen + idx*path.InfoLen
	info := &path.InfoField{}
	// (lhalm) need to explicitly create the subslice and assert access permission
	// if err := info.DecodeFromBytes((s.Raw)[infOffset : infOffset+path.InfoLen]); err != nil {
	// 	return nil, err
	// }
	subslice := (s.Raw)[infOffset : infOffset+path.InfoLen]
	assert forall i int :: 0 <= i && i <= len(subslice) ==> &(s.Raw)[i + infOffset] == &subslice[i] && acc(&subslice[i], p)
	if err := info.DecodeFromBytes(subslice, p); err != nil {
		fold infoFieldAcc(s.Raw, idx, p)
		return nil, err
	}
	fold infoFieldAcc(s.Raw, idx, p)
	return info, nil
}

// GetCurrentInfoField is a convenience method that returns the current hop field pointed to by the
// CurrINF index in the path meta header.
requires p > 0 && p <= 1
requires acc(s, p)
requires infoFieldAcc(s.Raw, int(s.BaseEmbedded.PathMeta.CurrINF), p)
ensures acc(s, p)
ensures infoFieldAcc(s.Raw, int(s.BaseEmbedded.PathMeta.CurrINF), p)
ensures err == nil ==> infoField != nil && acc(infoField)
func (s *Raw) GetCurrentInfoField(ghost p perm) (infoField *path.InfoField, err error) {
	return s.GetInfoField(int(s.BaseEmbedded.PathMeta.CurrINF), p)
}

// SetInfoField updates the InfoField at a given index.
requires p > 0 && p <= 1
requires acc(s, p)
requires infoFieldAcc(s.Raw, idx, p)
requires acc(info, p)
ensures acc(s, p)
ensures infoFieldAcc(s.Raw, idx, p)
ensures acc(info, p)
func (s *Raw) SetInfoField(info *path.InfoField, idx int, ghost p perm) error {
	unfold infoFieldAcc(s.Raw, idx, p)
	if idx >= s.BaseEmbedded.NumINF {
		// (lhalm) create error first to allow folding of the predicate
		err := serrors.New("InfoField index out of bounds", "max", s.BaseEmbedded.NumINF-1, "actual", idx)
		fold infoFieldAcc(s.Raw, idx, p)
		return err
	}
	if info == nil {
		fold infoFieldAcc(s.Raw, idx, p)
		return serrors.New("Infofield cannot be nil")
	}
	infOffset := MetaLen + idx*path.InfoLen
	// (lhalm) need to explicitly create the subslice and assert access permission
	subslice := (s.Raw)[infOffset : infOffset+path.InfoLen]
	assert forall i int :: 0 <= i && i <= len(subslice) ==> &(s.Raw)[i + infOffset] == &subslice[i] && acc(&subslice[i], p)
	// (lhalm) create error first to allow folding of the predicate
	err := info.SerializeTo(subslice, p)
	fold infoFieldAcc(s.Raw, idx, p)
	return err
}

// GetHopField returns the HopField at a given index.
requires 0 < p && p <= 1
requires acc(s, p)
requires hopFieldAcc(s.Raw, idx, s.BaseEmbedded.NumINF, p)
ensures acc(s, p)
ensures hopFieldAcc(s.Raw, idx, s.BaseEmbedded.NumINF, p)
ensures s.BaseEmbedded.PathMeta.CurrHF == old(s.BaseEmbedded.PathMeta.CurrHF)
ensures err == nil ==> hf != nil && acc(hf)
func (s *Raw) GetHopField(idx int, ghost p perm) (hf *path.HopField, err error) {
	unfold hopFieldAcc(s.Raw, idx, s.BaseEmbedded.NumINF, p)
	if idx >= s.BaseEmbedded.NumHops {
		// (lhalm) create error first to allow folding of the predicate
		err := serrors.New("HopField index out of bounds", "max", s.BaseEmbedded.NumHops-1, "actual", idx)
		fold hopFieldAcc(s.Raw, idx, s.BaseEmbedded.NumINF, p)
		return nil, err
		//return nil, serrors.New("HopField index out of bounds", "max", s.BaseEmbedded.NumHops-1, "actual", idx)
	}
	hopOffset := MetaLen + s.BaseEmbedded.NumINF*path.InfoLen + idx*path.HopLen
	hop := &path.HopField{}
	// (lhalm) need to explicitly create the subslice and assert access permission
	// if err := hop.DecodeFromBytes((s.Raw)[hopOffset : hopOffset+path.HopLen]); err != nil {
	// 	return nil, err
	// }
	subslice := (s.Raw)[hopOffset : hopOffset+path.HopLen]
	assert forall i int :: 0 <= i && i <= len(subslice) ==> &(s.Raw)[i + hopOffset] == &subslice[i] && acc(&subslice[i], p)
	if err := hop.DecodeFromBytes(subslice, p); err != nil {
		fold hopFieldAcc(s.Raw, idx, s.BaseEmbedded.NumINF, p)
		return nil, err
	}
	fold hopFieldAcc(s.Raw, idx, s.BaseEmbedded.NumINF, p)
	return hop, nil
}

// GetCurrentHopField is a convenience method that returns the current hop field pointed to by the
// CurrHF index in the path meta header.
requires p > 0 && p <= 1
requires acc(s, p)
requires hopFieldAcc(s.Raw, int(s.BaseEmbedded.PathMeta.CurrHF), s.BaseEmbedded.NumINF, p)
ensures acc(s, p)
ensures hopFieldAcc(s.Raw, int(s.BaseEmbedded.PathMeta.CurrHF), s.BaseEmbedded.NumINF, p)
ensures err == nil ==> hf != nil && acc(hf)
func (s *Raw) GetCurrentHopField(ghost p perm) (hf *path.HopField, err error) {
	return s.GetHopField(int(s.BaseEmbedded.PathMeta.CurrHF), p)
}

// SetHopField updates the HopField at a given index.
requires 0 < p && p <= 1
requires acc(s, p)
requires hopFieldAcc(s.Raw, idx, s.BaseEmbedded.NumINF, p)
requires acc(hop, p)
ensures acc(s, p)
ensures hopFieldAcc(s.Raw, idx, s.BaseEmbedded.NumINF, p)
ensures acc(hop, p)
func (s *Raw) SetHopField(hop *path.HopField, idx int, ghost p perm) error {
	unfold hopFieldAcc(s.Raw, idx, s.BaseEmbedded.NumINF, p)
	if idx >= s.BaseEmbedded.NumHops {
		// (lhalm) create error first to allow folding of the predicate
		err := serrors.New("HopField index out of bounds", "max", s.BaseEmbedded.NumHops-1, "actual", idx)
		fold hopFieldAcc(s.Raw, idx, s.BaseEmbedded.NumINF, p)
		return err
	}
	if hop == nil {
		fold hopFieldAcc(s.Raw, idx, s.BaseEmbedded.NumINF, p)
		return serrors.New("Hopfield cannot be nil")
	}
	hopOffset := MetaLen + s.BaseEmbedded.NumINF*path.InfoLen + idx*path.HopLen
	// (lhalm) need to explicitly create the subslice and assert access permission
	subslice := (s.Raw)[hopOffset : hopOffset+path.HopLen]
	assert forall i int :: 0 <= i && i <= len(subslice) ==> &(s.Raw)[i + hopOffset] == &subslice[i] && acc(&subslice[i], p)
	// (lhalm) create error first to allow folding of the predicate
	err := hop.SerializeTo(subslice, p)
	fold hopFieldAcc(s.Raw, idx, s.BaseEmbedded.NumINF, p)
	return err
}
