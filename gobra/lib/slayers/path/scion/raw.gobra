// Copyright 2020 Anapaya Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package scion

import (
//	"github.com/scionproto/scion/go/lib/serrors"
	"gobra/lib/serrors"
//	"github.com/scionproto/scion/go/lib/slayers/path"
	"gobra/lib/slayers/path"
)

// Raw is a raw representation of the SCION (data-plane) path type. It is designed to parse as
// little as possible and should be used if performance matters.
type Raw struct {
	Base
	Raw []byte
}

pred RawInvariant(r *Raw) {
	BaseInvariant(&r.Base) &&
	acc(&r.Raw) && 
	forall i int :: 0 <= i && i < len(r.Raw) ==> acc(&(r.Raw)[i])
}

// DecodeFromBytes only decodes the PathMetaHeader. Otherwise the nothing is decoded and simply kept
// as raw bytes.
requires acc(s)
requires forall i int :: 0 <= i && i < len(data) ==> acc(&data[i])
ensures res == nil ==> RawInvariant(s)
ensures res != nil ==> acc(s)
func (s *Raw) DecodeFromBytes(data []byte) (res error) {
	if err := s.Base.DecodeFromBytes(data, perm(1/2)); err != nil {
		return err
	}
	assert BaseInvariant(&s.Base)
	pathLen := s.Len()
	if len(data) < pathLen {
		unfold BaseInvariant(&s.Base)
		return serrors.New("RawPath raw too short", "expected", pathLen, "actual", len(data))
	}
	assert BaseInvariant(&s.Base)
	assert len(data) >= pathLen
	assert forall i int :: 0 <= i && i < pathLen ==> &data[:pathLen][i] == &data[i] && acc(&data[i])
	assert 0 <= pathLen
	s.Raw = data[:pathLen]
	fold RawInvariant(s)
	return nil
}

// SerializeTo writes the path to a slice. The slice must be big enough to hold the entire data,
// otherwise an error is returned.
requires 0 < p && p <= 1
requires RawInvariant(s)
// (joao) the following pre-condition seems to be an undocumented assumption. It may be promoted
//        to a condition in the RawInvariant predicate
// requires unfolding acc(RawInvariant(s), p) in len(s.Raw) >= MetaLen
requires forall i int :: 0 <= i && i < len(b) ==> acc(&b[i])
ensures RawInvariant(s)
func (s *Raw) SerializeTo(b []byte, ghost p perm) error {
	unfold RawInvariant(s)
	if s.Raw == nil {
		fold RawInvariant(s)
		return serrors.New("raw is nil")
	}
	if minLen := s.Len(); len(b) < minLen {
		fold RawInvariant(s)
		return serrors.New("buffer too small", "expected", minLen, "actual", len(b))
	}
	// XXX(roosd): This modifies the underlying buffer. Consider writing to data
	// directly.
	unfold BaseInvariant(&s.Base)
	// (joao) added parentheses surrounding (s.Raw)
	// (joao) testing without slicing operation, like suggested in my issue in the scion repository
	if err := s.PathMeta.SerializeTo((s.Raw)/*[:MetaLen]*/, p); err != nil {
		fold BaseInvariant(&s.Base)
		fold RawInvariant(s)
		return err
	}
	copy(b, s.Raw, p/2)
	fold BaseInvariant(&s.Base)
	fold RawInvariant(s)
	return nil
}

// Reverse reverses the path such that it can be used in the reverse direction.
//func (s *Raw) Reverse() error {
//	// XXX(shitz): The current implementation is not the most performant, since it parses the entire
//	// path first. If this becomes a performance bottleneck, the implementation should be changed to
//	// work directly on the raw representation.
//
//	decoded, err := s.ToDecoded()
//	if err != nil {
//		return err
//	}
//	if err := decoded.Reverse(); err != nil {
//		return err
//	}
//	if err := decoded.SerializeTo(s.Raw); err != nil {
//		return err
//	}
//	return s.DecodeFromBytes(s.Raw)
//}

//// ToDecoded transforms a scion.Raw to a scion.Decoded.
//func (s *Raw) ToDecoded() (*Decoded, error) {
//	// Serialize PathMeta to ensure potential changes are reflected Raw.
//	if err := s.PathMeta.SerializeTo(s.Raw[:MetaLen]); err != nil {
//		return nil, err
//	}
//	decoded := &Decoded{}
//	if err := decoded.DecodeFromBytes(s.Raw); err != nil {
//		return nil, err
//	}
//	return decoded, nil
//}

// GetInfoField returns the InfoField at a given index.
//requires p > 0
//requires acc(RawInvariant(s), p)
//ensures  acc(RawInvariant(s), p)
//func (s *Raw) GetInfoField(idx int, ghost p perm) (*path.InfoField, error) {
//	unfold acc(RawInvariant(s), p)
//	unfold acc(BaseInvariant(&s.Base), p)
//	if idx >= s.NumINF {
// (joao) introduces `tmp` to be able to fold predicate before returning
//		tmp := serrors.New("InfoField index out of bounds", "max", s.NumINF-1, "actual", idx)
//		fold acc(RawInvariant(s), p)
//		return nil, tmp
//	}
//	infOffset := MetaLen + idx*path.InfoLen
//	info := &path.InfoField{}
//	if err := info.DecodeFromBytes(s.Raw[infOffset : infOffset+path.InfoLen]); err != nil {
//		return nil, err
//	}
//	return info, nil
//}

// GetCurrentInfoField is a convenience method that returns the current hop field pointed to by the
// CurrINF index in the path meta header.
// func (s *Raw) GetCurrentInfoField() (*path.InfoField, error) {
//	return s.GetInfoField(int(s.PathMeta.CurrINF))
// }

//// SetInfoField updates the InfoField at a given index.
//func (s *Raw) SetInfoField(info *path.InfoField, idx int) error {
//	if idx >= s.NumINF {
//		return serrors.New("InfoField index out of bounds", "max", s.NumINF-1, "actual", idx)
//	}
//	if info == nil {
//		return serrors.New("Infofield cannot be nil")
//	}
//	infOffset := MetaLen + idx*path.InfoLen
//	return info.SerializeTo(s.Raw[infOffset : infOffset+path.InfoLen])
//}

//// GetHopField returns the HopField at a given index.
//func (s *Raw) GetHopField(idx int) (*path.HopField, error) {
//	if idx >= s.NumHops {
//		return nil, serrors.New("HopField index out of bounds", "max", s.NumHops-1, "actual", idx)
//	}
//	hopOffset := MetaLen + s.NumINF*path.InfoLen + idx*path.HopLen
//	hop := &path.HopField{}
//	if err := hop.DecodeFromBytes(s.Raw[hopOffset : hopOffset+path.HopLen]); err != nil {
//		return nil, err
//	}
//	return hop, nil
//}

//// GetCurrentHopField is a convenience method that returns the current hop field pointed to by the
//// CurrHF index in the path meta header.
//func (s *Raw) GetCurrentHopField() (*path.HopField, error) {
//	return s.GetHopField(int(s.PathMeta.CurrHF))
//}

//// SetHopField updates the HopField at a given index.
//func (s *Raw) SetHopField(hop *path.HopField, idx int) error {
//	if idx >= s.NumHops {
//		return serrors.New("HopField index out of bounds", "max", s.NumHops-1, "actual", idx)
//	}
//	if hop == nil {
//		return serrors.New("Hopfield cannot be nil")
//	}
//	hopOffset := MetaLen + s.NumINF*path.InfoLen + idx*path.HopLen
//	return hop.SerializeTo(s.Raw[hopOffset : hopOffset+path.HopLen])
//}