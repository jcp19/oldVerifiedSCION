// Copyright 2020 Anapaya Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package slayers

import (
	"encoding/binary"
	// (joao) "fmt" package not supported yet
	// "fmt"
	"net"

	//"github.com/google/gopacket"
	"gobra/dependencies/gopacket"
	//"github.com/google/gopacket/layers"
	"gobra/dependencies/gopacket/layers"

	"gobra/lib/addr"
	"gobra/lib/common"
	"gobra/lib/serrors"
	//"github.com/scionproto/scion/go/lib/slayers/path/empty"
	"gobra/lib/slayers/path/empty"
	//"github.com/scionproto/scion/go/lib/slayers/path/onehop"
	"gobra/lib/slayers/path/onehop"
	//"github.com/scionproto/scion/go/lib/slayers/path/scion"
	"gobra/lib/slayers/path/scion"

	"gobra/verifyutils"
)

const (
	// LineLen is the length of a SCION header line in bytes.
	LineLen = 4
	// CmnHdrLen is the length of the SCION common header in bytes.
	CmnHdrLen = 12
	// SCIONVersion is the currently supported version of the SCION header format. Different
	// versions are not guaranteed to be compatible to each other.
	SCIONVersion = 0
)

// PathType indicates the type of the path contained in the SCION header.
type PathType uint8

// (joao) Hidden for performance
func (t PathType) String() string {
	switch t {
	case PathTypeEmpty:
		return "Empty (0)"
	case PathTypeSCION:
		return "SCION (1)"
	case PathTypeOneHop:
		return "OneHop (2)"
	case PathTypeEPIC:
		return "EPIC (3)"
	case PathTypeCOLIBRI:
		return "COLIBRI (4)"
	}
	// (joao) fmt.Sprintf not supported
	// return fmt.Sprintf("UNKNOWN (%d)", t)
	return verifyutils.HavocString()
}

// PathType constants
// (joao) used to be defined in terms of iota
const (
	PathTypeEmpty PathType = 0
	PathTypeSCION PathType = 1
	PathTypeOneHop PathType = 2
	PathTypeEPIC PathType = 3
	PathTypeCOLIBRI PathType = 4
)

// AddrLen indicates the length of a host address in the SCION header. The four possible lengths are
// 4, 8, 12, or 16 bytes.
type AddrLen uint8

// AddrLen constants
// (joao) used to be defined in terms of iota
const (
	AddrLen4 AddrLen = 0
	AddrLen8 AddrLen = 1
	AddrLen12 AddrLen = 2
	AddrLen16 AddrLen = 3
)
ghost const AddrLenError AddrLen = 4

ghost
pure func validAddrLen(addrLen AddrLen) bool {
	return addrLen == AddrLen4 || addrLen == AddrLen8 || addrLen == AddrLen12 || addrLen == AddrLen16
}

// AddrType indicates the type of a host address of a given length in the SCION header. There are
// four possible types per address length.
type AddrType uint8

// AddrType constants
// (joao) used to be defined in terms of iota
const (
	T4Ip AddrType = 0
	T4Svc AddrType = 1
)

// AddrLen16 types
// (joao) used to be defined in terms of iota
const (
	T16Ip AddrType = 0
)

// Path is the path contained in the SCION header.
// TODO: (joao) implement all paths as subtypes of Path; must reflect all perms required in their specs
type Path interface {
	// (joao) must hold for every receiver in the call of DecodeFromBytes. Represents
	//        permission to (possibly non initialized) memory that stores a Path
	pred UninitializedMem()
	// (joao) must hold in every valid instance of a Path
	pred Mem()
	// (joao) it should be possible to retrieve UninitializedMem() from Mem().
	//        this should be a ghost operation but ghost interface methods are currently not supported.
	requires Mem()
	ensures UninitializedMem()
	ExchangePerms()
	// SerializeTo serializes the path into the provided buffer.
	requires Mem() // (joao) there are implementations of this interface that modify the Path structure when serializing (e.g. scion.Raw)
	requires forall i int :: 0 <= i && i < len(b) ==> acc(&b[i])
	ensures  Mem()
	ensures  forall i int :: 0 <= i && i < len(b) ==> acc(&b[i])
	SerializeTo(b []byte) error
	// DecodesFromBytes decodes the path from the provided buffer.
	requires UninitializedMem()
 	// (joao) there are implementations of this interface (e.g. scion.Raw) that store b and use it as internal data
	requires forall i int :: 0 <= i && i < len(b) ==> acc(&b[i]) 
	ensures  res == nil ==> Mem()
	DecodeFromBytes(b []byte) (res error)
	// Reverse reverses a path such that it can be used in the reversed direction.
	//
	// XXX(shitz): This method should possibly be moved to a higher-level path manipulation package.
	requires Mem()
	ensures res == nil ==> Mem()
	Reverse() (res error)
	// Len returns the length of a path in bytes.
	requires acc(Mem(), _)
	Len() int
}

pred Empty(o empty.Path) {
	o.Mem()
}

pred EmptyUninitialized(o empty.Path) {
	o.UninitializedMem()
}


// (joao) Fix when needed
// (joao) TODO: do the same for scion.Raw and onehop.Path after fixing interface issues
/*
(empty.Path) implements Path {
	pred Mem := Empty

	pred UninitializedMem := EmptyUninitialized

	(x empty.Path) SerializeTo(b []byte) (err error) {
		unfold Empty(x)
		err = x.SerializeTo(b)
		fold Empty(x)
	}

	(x empty.Path) DecodeFromBytes(b []byte) error {
		unfold acc(EmptyUninitialized(x))
		res := x.DecodeFromBytes(b)
		// (joao) syntax too restrictive, allow for if's to be able to fold stuff
	}

	(x empty.Path) Reverse() error {
		return x.Reverse()
	}

	(x empty.Path) Len() int {
		return x.Len()
	}

	(x empty.Path) ExchangePerms() {
		x.ExchangePerms()
	}
}
*/

// SCION is the header of a SCION packet.
type SCION struct {
	// (joao) No support for embedded fields, added field EmbeddedBaseLayer instead
	// layers.BaseLayer
	EmbeddedBaseLayer layers.BaseLayer

	// Common Header fields

	// Version is version of the SCION Header. Currently, only 0 is supported.
	Version uint8
	// TrafficClass denotes the traffic class. Its value in a received packet or fragment might be
	// different from the value sent by the packet’s source. The current use of the Traffic Class
	// field for Differentiated Services and Explicit Congestion Notification is specified in
	// RFC2474 and RFC3168
	TrafficClass uint8
	// FlowID is a 20-bit field used by a source to label sequences of packets to be treated in the
	// network as a single flow. It is mandatory to be set.
	FlowID uint32
	// NextHdr  encodes the type of the first header after the SCION header. This can be either a
	// SCION extension or a layer-4 protocol such as TCP or UDP. Values of this field respect and
	// extend IANA’s assigned internet protocol numbers.
	NextHdr common.L4ProtocolType
	// HdrLen is the length of the SCION header in multiples of 4 bytes. The SCION header length is
	// computed as HdrLen * 4 bytes. The 8 bits of the HdrLen field limit the SCION header to a
	// maximum of 1024 bytes.
	HdrLen uint8
	// PayloadLen is the length of the payload in bytes. The payload includes extension headers and
	// the L4 payload. This field is 16 bits long, supporting a maximum payload size of 64KB.
	PayloadLen uint16

	// PathType specifies the type of path in this SCION header.
	PathType PathType

	// DstAddrType (2 bit) is the type of the destination address.
	DstAddrType AddrType
	// DstAddrLen (2 bit) is the length of the destination address. Supported address length are 4B
	// (0), 8B (1), 12B (2), and 16B (3).
	DstAddrLen AddrLen
	// SrcAddrType (2 bit) is the type of the source address.
	SrcAddrType AddrType
	// SrcAddrLen (2 bit) is the length of the source address. Supported address length are 4B (0),
	// 8B (1), 12B (2), and 16B (3).
	SrcAddrLen AddrLen

	// Address header fields.

	// DstIA is the destination ISD-AS.
	DstIA addr.IA
	// SrcIA is the source ISD-AS.
	SrcIA addr.IA
	// RawDstAddr is the destination address.
	RawDstAddr []byte
	// RawSrcAddr is the source address.
	RawSrcAddr []byte

	// Path is the path contained in the SCION header. It depends on the PathType field.
	Path Path
}

pure
requires acc(InvariantSCION(s), _)
func (s *SCION) getRawSrcAddr() []byte {
	return unfolding acc(InvariantSCION(s), _) in s.RawSrcAddr
}

// (joao) causes Gobra to not terminate
requires acc(InvariantSCION(s), 1/1000)
requires 0 <= i && i < s.getLenRawSrcAddr()
ensures acc(InvariantSCION(s), 1/1000)
func (s *SCION) getRawSrcAddrIdx(i int) (res byte) // {
// 	res = verifyutils.BytesIndex(unfolding acc(InvariantSCION(s), 1/10000) in s.RawSrcAddr, i)
// }

// (joao) causes Gobra to not terminate
requires acc(InvariantSCION(s), 1/1000)
requires 0 <= i && i < s.getLenRawDstAddr()
ensures acc(InvariantSCION(s), 1/1000)
func (s *SCION) getRawDstAddrIdx(i int) (res byte) // {
// 	res = verifyutils.BytesIndex(unfolding acc(InvariantSCION(s), 1/10000) in s.RawDstAddr, i)
// }

pure
requires acc(InvariantSCION(s), _)
ensures res == unfolding acc(InvariantSCION(s), _) in len(s.RawSrcAddr)
// (joao) TODO: add this property to the Invariant
ensures res % 2 == 0
func (s *SCION) getLenRawSrcAddr() (res int) // {
//	return unfolding acc(InvariantSCION(s), _) in len(s.RawSrcAddr)
//}

pure
requires acc(InvariantSCION(s), _)
func (s *SCION) getRawDstAddr() []byte {
	return unfolding acc(InvariantSCION(s), _) in s.RawDstAddr
}

pure
requires acc(InvariantSCION(s), _)
ensures res == unfolding acc(InvariantSCION(s), _) in len(s.RawDstAddr)
// (joao) cannot prove this postcondition if body is uncommented, but the proof of this
//        is analogous to `proveLenRawSrcAddrHasEvenLen`
ensures res % 2 == 0
func (s *SCION) getLenRawDstAddr() (res int) // {
//	return unfolding acc(InvariantSCION(s), _) in len(s.RawDstAddr)
//}

pure
requires acc(InvariantSCION(s), _)
func (s *SCION) getDstIA() addr.IA {
	return unfolding acc(InvariantSCION(s), _) in s.DstIA
}

pure
requires acc(InvariantSCION(s), _)
func (s *SCION) getSrcIA() addr.IA {
	return unfolding acc(InvariantSCION(s), _) in s.SrcIA
}

ensures res == (int(addrLen) + 1) * LineLen
pure func addrBytes(addrLen AddrLen) (res int) {
	return (int(addrLen) + 1) * LineLen
}

ghost
pure func bogusIntMinAddrLen() int

ghost
requires validAddrLen(l)
pure func minAddrLen(l AddrLen) int {
	return l == AddrLen4? 4: (l == AddrLen8? 8: (l == AddrLen12? 12 : (l == AddrLen16? 16: bogusIntMinAddrLen())))
}

pred InvariantSCION(s *SCION) {
	acc(s) &&
	verifyutils.BytesAcc(s.RawSrcAddr) &&
	verifyutils.BytesAcc(s.RawDstAddr) &&
	(s.RawSrcAddr != nil ==> validSrcAddr(s)) &&
	(s.RawDstAddr != nil ==> validDstAddr(s)) &&
	true
	// TODO:
	// s.Path.Mem()
	// - be more specific about the relation between addrtype and addrlen?
	// - length of raw addresses should be even
}

ghost
requires acc(s, _)
pure func validSrcAddr(s *SCION) bool {
	return validAddrLen(s.SrcAddrLen) && len(s.RawSrcAddr) >= minAddrLen(s.SrcAddrLen)
}

ghost
requires acc(s, _)
pure func validDstAddr(s *SCION) bool {
	return validAddrLen(s.DstAddrLen) && len(s.RawDstAddr) >= minAddrLen(s.DstAddrLen)
}

//(joao) Fails, as expected
//ghost
//requires InvariantSCION(s)
//func soundInvariantSCION1(s *SCION) {
//	unfold InvariantSCION(s)
//	assert false
//}

/* pure */
func (s *SCION) LayerType() gopacket.LayerType // {
// (joao) slayers.LayerTypeSCION not defined yet
//	return LayerTypeSCION
// }

/* pure */
// (joao) LayerClass not implemented
// func (s *SCION) CanDecode() gopacket.LayerClass {
//	return LayerTypeSCION
//}

requires acc(InvariantSCION(s), 1/100)
func (s *SCION) NextLayerType() gopacket.LayerType // {
//	return scionNextLayerType(s.NextHdr)
//}

//(joao) the field `Payload` is implemented in the embedded field `layers.BaseLayer`
//(joao) `layers.BaseLayer` is implemented in a third party package
//requires acc(s, _)
//func (s *SCION) LayerPayload() []byte
//{
//	return s.Payload
//}

// (joao) Flow not implemented
//func (s *SCION) NetworkFlow() gopacket.Flow {
//	// TODO(shitz): Investigate how we can use gopacket.Flow.
//	return gopacket.Flow{}
//}

// (joao) no support for gopacket
//func (s *SCION) SerializeTo(b gopacket.SerializeBuffer, opts gopacket.SerializeOptions) error {
//	scnLen := CmnHdrLen + s.AddrHdrLen() + s.Path.Len()
//	buf, err := b.PrependBytes(scnLen)
//	if err != nil {
//		return err
//	}
//	if opts.FixLengths {
//		s.HdrLen = uint8(scnLen / LineLen)
//		s.PayloadLen = uint16(len(b.Bytes()) - int(scnLen))
//	}
//	// Serialize common header.
//	firstLine := uint32(s.Version&0xF)<<28 | uint32(s.TrafficClass)<<20 | s.FlowID&0xFFFFF
//	binary.BigEndian.PutUint32(buf[:4], firstLine)
//	buf[4] = uint8(s.NextHdr)
//	buf[5] = s.HdrLen
//	binary.BigEndian.PutUint16(buf[6:8], s.PayloadLen)
//	buf[8] = uint8(s.PathType)
//	buf[9] = uint8(s.DstAddrType&0x3)<<6 | uint8(s.DstAddrLen&0x3)<<4 |
//		uint8(s.SrcAddrType&0x3)<<2 | uint8(s.SrcAddrLen&0x3)
//	binary.BigEndian.PutUint16(buf[10:12], 0)
//
//	// Serialize address header.
//	if err := s.SerializeAddrHdr(buf[CmnHdrLen:]); err != nil {
//		return err
//	}
//	offset := CmnHdrLen + s.AddrHdrLen()
//
//	// Serialize path header.
//	return s.Path.SerializeTo(buf[offset:])
//}

// THIS(2)
// DecodeFromBytes decodes the SCION layer. DecodeFromBytes resets the internal state of this layer
// to the state defined by the passed-in bytes. Slices in the SCION layer reference the passed-in
// data, so care should be taken to copy it first should later modification of data be required
// before the SCION layer is discarded.
// func (s *SCION) DecodeFromBytes(data []byte, df gopacket.DecodeFeedback) error {
/*
	// Decode common header.
	if len(data) < CmnHdrLen {
		df.SetTruncated()
		return serrors.New("packet is shorter than the common header length",
			"min", CmnHdrLen, "actual", len(data))
	}
*/
//	firstLine := binary.BigEndian.Uint32(data[:4])
//	s.Version = uint8(firstLine >> 28)
//	s.TrafficClass = uint8((firstLine >> 20) & 0xFF)
//	s.FlowID = firstLine & 0xFFFFF
//	s.NextHdr = common.L4ProtocolType(data[4])
//	s.HdrLen = data[5]
//	s.PayloadLen = binary.BigEndian.Uint16(data[6:8])
//	s.PathType = PathType(data[8])
//	s.DstAddrType = AddrType(data[9] >> 6)
//	s.DstAddrLen = AddrLen(data[9] >> 4 & 0x3)
//	s.SrcAddrType = AddrType(data[9] >> 2 & 0x3)
//	s.SrcAddrLen = AddrLen(data[9] & 0x3)
//
//	// Decode address header.
//	if err := s.DecodeAddrHdr(data[CmnHdrLen:]); err != nil {
//		df.SetTruncated()
//		return err
//	}
//	addrHdrLen := s.AddrHdrLen()
//	offset := CmnHdrLen + addrHdrLen
//
//	// Decode path header.
//	var err error
//	hdrBytes := int(s.HdrLen) * LineLen
//	pathLen := hdrBytes - CmnHdrLen - addrHdrLen
//	if pathLen < 0 {
//		return serrors.New("invalid header, negative pathLen",
//			"hdrBytes", hdrBytes, "addrHdrLen", addrHdrLen, "CmdHdrLen", CmnHdrLen)
//	}
//
//	switch s.PathType {
//	case PathTypeEmpty:
//		if _, ok := s.Path.(empty.Path); ok {
//			break
//		}
//		s.Path = empty.Path{}
//		if pathLen != 0 {
//			return serrors.New("invalid header, non-empty empty path", "hdrBytes", hdrBytes,
//				"addrHdrLen", addrHdrLen, "CmdHdrLen", CmnHdrLen, "pathLen", pathLen)
//		}
//	case PathTypeSCION:
//		// Only allocate a SCION path if necessary. This reduces memory allocation and GC overhead
//		// considerably (3x improvement for DecodeFromBytes performance)
//		if _, ok := s.Path.(*scion.Raw); ok {
//			break
//		}
//		s.Path = &scion.Raw{}
//	case PathTypeOneHop:
//		if _, ok := s.Path.(*onehop.Path); ok {
//			break
//		}
//		s.Path = &onehop.Path{}
//	case PathTypeEPIC, PathTypeCOLIBRI:
//		return serrors.New("unsupported path type", "type", s.PathType.String())
//	default:
//		return serrors.New("unknown path type", "type", s.PathType.String())
//	}
//
//	if minLen := offset + pathLen; len(data) < minLen {
//		df.SetTruncated()
//		return serrors.New("provided buffer is too small", "expected", minLen, "actual", len(data))
//	}
//	err = s.Path.DecodeFromBytes(data[offset : offset+pathLen])
//	if err != nil {
//		return err
//	}
//	s.Contents = data[:hdrBytes]
//	s.Payload = data[hdrBytes:]
//
//	return nil
//}

// (joao) no support for gopacket
//func decodeSCION(data []byte, pb gopacket.PacketBuilder) error {
//	scn := &SCION{}
//	err := scn.DecodeFromBytes(data, pb)
//	if err != nil {
//		return err
//	}
//	pb.AddLayer(scn)
//	pb.SetNetworkLayer(scn)
//	return pb.NextDecoder(scionNextLayerType(scn.NextHdr))
//}

// (joao) global variables still not supported
func scionNextLayerType(t common.L4ProtocolType) gopacket.LayerType // {
//	switch t {
//	case common.L4UDP:
//		return LayerTypeSCIONUDP
//	case common.L4SCMP:
//		return LayerTypeSCMP
//	case common.L4BFD:
//		return layers.LayerTypeBFD
//	case common.HopByHopClass:
//		return LayerTypeHopByHopExtn
//	case common.End2EndClass:
//		return LayerTypeEndToEndExtn
//	default:
//		return gopacket.LayerTypePayload
//	}
//}

// DstAddr parses the destination address into a net.Addr. The returned net.Addr references data
// from the underlaying layer data. Changing the net.Addr object might lead to inconsistent layer
// information and thus should be treated read-only. Instead, SetDstAddr should be used to update
// the destination address.
/*
requires p > 0
requires acc(InvariantSCION(s), p)
ensures acc(InvariantSCION(s), p)
func (s *SCION) DstAddr(ghost p perm) (net.Addr, error) {
	unfold acc(InvariantSCION(s), p)
	// (joao) this call used to be part of the return statement
	res, err := parseAddr(s.DstAddrType, s.DstAddrLen, s.RawDstAddr, p)
	fold acc(InvariantSCION(s), p)
	return res, err
}*/

// SrcAddr parses the source address into a net.Addr. The returned net.Addr references data from the
// underlaying layer data. Changing the net.Addr object might lead to inconsistent layer information
// and thus should be treated read-only. Instead, SetDstAddr should be used to update the source
// address.
/*
requires p > 0
requires acc(InvariantSCION(s), p)
ensures acc(InvariantSCION(s), p)
func (s *SCION) SrcAddr(ghost p perm) (net.Addr, error) {
	unfold acc(InvariantSCION(s), p)
	// (joao) this call used to be part of the return statement
	res, err := parseAddr(s.SrcAddrType, s.SrcAddrLen, s.RawSrcAddr, p)
	fold acc(InvariantSCION(s), p)
	return res, err
}
*/

// SetDstAddr sets the destination address and updates the DstAddrLen/Type fields accordingly.
// SetDstAddr takes ownership of dst and callers should not write to it after calling SetDstAddr.
// Changes to dst might leave the layer in an inconsistent state.
// (joao) Verified
requires InvariantSCION(s) && dst.mem()
ensures InvariantSCION(s)
func (s *SCION) SetDstAddr(dst net.Addr) (ret error) {
	unfold InvariantSCION(s)
	var err error
	s.DstAddrLen, s.DstAddrType, s.RawDstAddr, err = packAddr(dst)
	ghost if err == nil {
		assert validDstAddr(s) && len(s.RawDstAddr) >= minAddrLen(s.DstAddrLen)
		assert (s.RawSrcAddr != nil ==> validSrcAddr(s))
		assert verifyutils.BytesAcc(s.RawSrcAddr) 
		assert verifyutils.BytesAcc(s.RawDstAddr) 
		fold InvariantSCION(s)
	} else {
		assert s.DstAddrLen  == 0
		assert s.DstAddrType == 0
		assert s.RawDstAddr  == nil
		assert verifyutils.BytesAcc(s.RawSrcAddr)
		assert verifyutils.BytesAcc(s.RawDstAddr) 
		fold InvariantSCION(s)
	}
	return err
}

// SetSrcAddr sets the source address and updates the DstAddrLen/Type fields accordingly.
// SetSrcAddr takes ownership of src and callers should not write to it after calling SetSrcAddr.
// Changes to src might leave the layer in an inconsistent state.
// (joao) Verified
requires InvariantSCION(s) && src.mem()
ensures  InvariantSCION(s)
func (s *SCION) SetSrcAddr(src net.Addr) (ret error) {
	var err error
	unfold InvariantSCION(s)
	s.SrcAddrLen, s.SrcAddrType, s.RawSrcAddr, err = packAddr(src)
	ghost if err == nil {
		assert validSrcAddr(s) && len(s.RawSrcAddr) >= minAddrLen(s.SrcAddrLen)
		assert (s.RawDstAddr != nil ==> validDstAddr(s))
		assert verifyutils.BytesAcc(s.RawSrcAddr) 
		assert verifyutils.BytesAcc(s.RawDstAddr) 
		fold InvariantSCION(s)
	} else {
		assert s.SrcAddrLen  == 0
		assert s.SrcAddrType == 0
		assert s.RawSrcAddr  == nil
		assert verifyutils.BytesAcc(s.RawSrcAddr)
		assert verifyutils.BytesAcc(s.RawDstAddr) 
		fold InvariantSCION(s)
	}
	return err
}

// (joao) requires implementation proof that IPAddr implements Addr to verify the body
requires addrLen == AddrLen4  ==> (addrType == T4Ip || addrType == T4Svc)
requires addrLen == AddrLen16 ==> addrType == T16Ip
requires addrLen == AddrLen4 ==> len(raw) >= 4
requires addrLen == AddrLen16 ==> len(raw) >= 16
requires forall i int :: 0 <= i && i < len(raw) ==> acc(&raw[i])
ensures addrLen != AddrLen4 && addrLen != AddrLen16 ==> resErr != nil
ensures resAddr.mem()
func parseAddr(addrType AddrType, addrLen AddrLen, raw []byte) (resAddr net.Addr, resErr error) //{
//	switch addrLen {
//	case AddrLen4:
//		switch addrType {
//		case T4Ip:
//			return &net.IPAddr{IP: net.IP(raw)}, nil
//		case T4Svc:
//			return addr.HostSVC(binary.BigEndian.Uint16(raw[:addr.HostLenSVC])), nil
//		}
//	case AddrLen16:
//		switch addrType {
//		case T16Ip:
//			return &net.IPAddr{IP: net.IP(raw)}, nil
//		}
//	}
//	return nil, serrors.New("unsupported address type/length combination",
//		"type", addrType, "len", addrLen)
//}

// (joao) requires implementation proof that IPAddr implements Addr to verify the body
requires hostAddr.mem()
ensures verifyutils.BytesAcc(s)
// the LHS of this implication is necessary, because AddrLen4 is 0 and 0 is the value returned for addrLen
// in case of error
ensures err == nil ==> addrLen == AddrLen4 ==> (addrType == T4Svc || addrType == T4Ip)
ensures err == nil ==> addrLen == AddrLen16 ==> addrType == T16Ip
ensures err == nil ==> validAddrLen(addrLen) && len(s) >= minAddrLen(addrLen)
ensures err != nil ==> addrLen == 0 && addrType == 0 && s == nil
func packAddr(hostAddr net.Addr) (addrLen AddrLen, addrType AddrType, s []byte, err error) // {
//	switch a := hostAddr.(type) {
//	case *net.IPAddr:
//		if ip := a.IP.To4(); ip != nil {
//			return AddrLen4, T4Ip, ip, nil
//		}
//		return AddrLen16, T16Ip, a.IP, nil
//	case addr.HostSVC:
//		return AddrLen4, T4Svc, a.PackWithPad(2), nil
//	}
// (joao) node not in tree: Network
//	return 0, 0, nil, serrors.New("unsupported address", "addr", hostAddr)
//}

// AddrHdrLen returns the length of the address header (destination and source ISD-AS-Host triples)
// in bytes.
requires acc(InvariantSCION(s), _)
ensures unfolding acc(InvariantSCION(s), _) in res == 2*addr.IABytes + addrBytes(s.DstAddrLen) + addrBytes(s.SrcAddrLen)
// (joao) if the body of the function is uncommented, this post-condition will not verify because Gobra does not
//        take into account that uint cannot be negative.
ensures res >= 2*addr.IABytes
ensures unfolding acc(InvariantSCION(s), _) in addrBytes(s.DstAddrLen) >= 0
ensures unfolding acc(InvariantSCION(s), _) in addrBytes(s.SrcAddrLen) >= 0
pure func (s *SCION) AddrHdrLen() (res int) // {
//	return unfolding InvariantSCION(s) in 2*addr.IABytes + addrBytes(s.DstAddrLen) + addrBytes(s.SrcAddrLen)
//}

// SerializeAddrHdr serializes destination and source ISD-AS-Host address triples into the provided
// buffer. The caller must ensure that the correct address types and lengths are set in the SCION
// layer, otherwise the results of this method are undefined.
/* TODO: is causing Gobra to take a long time
preserves acc(InvariantSCION(s), 1/100)
preserves forall i int :: 0 <= i && i < len(buf) ==> acc(&buf[i])
func (s *SCION) SerializeAddrHdr(buf []byte, ghost p perm) (err error) {
	if len(buf) < s.AddrHdrLen() {
		return serrors.New("provided buffer is too small", "expected", s.AddrHdrLen(),
			"actual", len(buf))
	}
	assert unfolding acc(InvariantSCION(s), _) in len(buf) >= 2*addr.IABytes + addrBytes(s.DstAddrLen) + addrBytes(s.SrcAddrLen)
	unfold acc(InvariantSCION(s), 1/100)
	dstAddrBytes := addrBytes(s.DstAddrLen)
	srcAddrBytes := addrBytes(s.SrcAddrLen)
	offset := 0
	assert len(buf) == len(buf[offset:])
	assert forall i int :: 0 <= i && i < len(buf) ==> &buf[i] == &(buf[offset:][i])
	s.DstIA.Write(buf[offset:])
	offset += addr.IABytes
	assert len(buf) == len(buf[offset:]) + offset
	assert forall i int :: 0 <= i && i < len(buf[offset:]) ==> &buf[i + offset] == &(buf[offset:][i])
	s.SrcIA.Write(buf[offset:])
	offset += addr.IABytes
	// (joao) Outlined call to copy
	// copy(buf[offset:offset+dstAddrBytes], s.RawDstAddr)
	assert offset <= len(buf)
	assert offset + dstAddrBytes <= len(buf)
//	assert forall i int :: 0 <= i && i < len(buf[offset:offset+dstAddrBytes]) ==> &buf[i + offset] == &(buf[offset:offset+dstAddrBytes][i])
//	verifyutils.OutlineMemorySafeCopy(buf[offset:offset+dstAddrBytes], s.RawDstAddr)
//	offset += dstAddrBytes
//	copy(buf[offset:offset+srcAddrBytes], s.RawSrcAddr)
	assume false
	fold acc(InvariantSCION(s), 1/100)
	return nil
}
*/

/*
// (joao) Unverified -> outline!
// DecodeAddrHdr decodes the destination and source ISD-AS-Host address triples from the provided
// buffer. The caller must ensure that the correct address types and lengths are set in the SCION
// layer, otherwise the results of this method are undefined.
requires InvariantSCION(s) // (joao) Maybe the precondition can be weaker: acc(s)?
requires forall i int :: 0 <= i && i < len(data) ==> acc(&data[i])
// ensures  InvariantSCION(s)
func (s *SCION) DecodeAddrHdr(data []byte) (res error) {
	if len(data) < s.AddrHdrLen() {
		return serrors.New("provided buffer is too small", "expected", s.AddrHdrLen(),
			"actual", len(data))
	}
	offset := 0
	unfold InvariantSCION(s)
	assert len(data[offset:]) == len(data)
	assert forall i int :: 0 <= i && i < len(data[offset:]) ==> &(data[offset:])[i] == &data[offset + i]
	s.DstIA = addr.IAFromRaw(data[offset:])
	offset += addr.IABytes
	assert len(data[offset:]) == len(data) - offset
	assert forall i int :: 0 <= i && i < len(data[offset:]) ==> &(data[offset:])[i] == &data[offset + i]
	s.SrcIA = addr.IAFromRaw(data[offset:])
	offset += addr.IABytes
	dstAddrBytes := addrBytes(s.DstAddrLen)
	srcAddrBytes := addrBytes(s.SrcAddrLen)
	assert len(data) >= 2 * addr.IABytes + srcAddrBytes + dstAddrBytes
	assume false
	assert len(data[offset:]) == len(data) - offset
	assert forall i int :: 0 <= i && i < len(data[offset:]) ==> &(data[offset:])[i] == &data[offset + i]
	s.RawDstAddr = data[offset : offset+dstAddrBytes]
	offset += dstAddrBytes
	assert len(data[offset:]) == len(data) - offset
	assert forall i int :: 0 <= i && i < len(data[offset:]) ==> &(data[offset:])[i] == &data[offset + i]
	s.RawSrcAddr = data[offset : offset+srcAddrBytes]
	/*
	acc(s) &&
	(s.RawSrcAddr != nil ==> (validAddrLen(s.SrcAddrLen) && lengthToAddrLen(len(s.RawSrcAddr)) == s.SrcAddrLen)) &&
	(forall i int :: 0 <= i && i < len(s.RawSrcAddr) ==> acc(&(s.RawSrcAddr)[i])) &&
	(s.RawDstAddr != nil ==> (validAddrLen(s.DstAddrLen) && lengthToAddrLen(len(s.RawDstAddr)) == s.DstAddrLen)) &&
	(forall i int :: 0 <= i && i < len(s.RawDstAddr) ==> acc(&(s.RawDstAddr)[i])) &&
	*/

//	// fold InvariantSCION(s)
//	return nil
//}

// (joao) Verified
// computeChecksum computes the checksum with the SCION pseudo header.
preserves s != nil ==> acc(InvariantSCION(s), 1/100)
preserves forall j int :: 0 <= j && j < len(upperLayer) ==> acc(&upperLayer[j], 1/10000)
ensures retErr != nil ==> ret == 0
ensures s == nil ==> retErr != nil
ensures s != nil && s.getLenRawSrcAddr() > 0 && s.getLenRawDstAddr() > 0 ==> retErr == nil
func (s *SCION) computeChecksum(upperLayer []byte, protocol uint8) (ret uint16, retErr error) {
	if s == nil {
		return 0, serrors.New("SCION header missing")
	}
	csum, err := s.pseudoHeaderChecksum(len(upperLayer), protocol)
	if err != nil {
		return 0, err
	}
	csum = s.upperLayerChecksum(upperLayer, csum)
	folded := s.foldChecksum(csum)
	return folded, nil
}

// (joao) Verified
requires acc(InvariantSCION(s), 1/100)
ensures acc(InvariantSCION(s), 1/100)
ensures s.getLenRawSrcAddr() == 0 ==> resErr != nil
ensures s.getLenRawDstAddr() == 0 ==> resErr != nil
ensures s.getLenRawSrcAddr() > 0 && s.getLenRawDstAddr() > 0 ==> resErr == nil
func (s *SCION) pseudoHeaderChecksum(length int, protocol uint8) (resUint uint32, resErr error) {
	// (joao) len(s.RawDstAddr) replaced by s.getLenRawDstAddr() to avoid unfoldings
	// if len(s.RawDstAddr) == 0 {
	if s.getLenRawDstAddr() == 0 {
		return 0, serrors.New("destination address missing")
	}
	// (joao) len(s.RawSrcAddr) replaced by s.getLenRawSrcAddr() to avoid unfoldings
	// if len(s.RawSrcAddr) == 0 {
	if s.getLenRawSrcAddr() == 0 {
		return 0, serrors.New("source address missing")
	}
	var csum uint32
	var srcIA@, dstIA@ [8]byte

	// (joao) outlining this section causes Gobra to crash
	// s.SrcIA.Write(srcIA[:])
	// s.DstIA.Write(dstIA[:])
	// (joao) rewrote as:
	srcIASlice := srcIA[:]
	dstIASlice := dstIA[:]
	assert len(srcIASlice) == 8
	assert forall i int :: 0 <= i && i < 8 ==> &(srcIASlice)[i] == &srcIA[i]
	assert len(dstIASlice) == 8
	assert forall i int :: 0 <= i && i < 8 ==> &(dstIASlice)[i] == &dstIA[i]
	s.pseudoHeaderChecksumOutlineBlock1(srcIASlice, dstIASlice)
	assert forall i int :: 0 <= i && i < 8 ==> acc(&srcIA[i])
	assert forall i int :: 0 <= i && i < 8 ==> acc(&dstIA[i])

	invariant 0 <= i && i <= 8
	invariant i % 2 == 0
	invariant forall i int :: 0 <= i && i < 8 ==> acc(&srcIA[i])
	invariant forall i int :: 0 <= i && i < 8 ==> acc(&dstIA[i])
	for i := 0; i < 8; i += 2 {
		csum += uint32(srcIA[i]) << 8
		csum += uint32(srcIA[i+1])
		csum += uint32(dstIA[i]) << 8
		csum += uint32(dstIA[i+1])
	}

	// Address length is guaranteed to be a multiple of 2 by the protocol.
	invariant acc(InvariantSCION(s), 1/200)
	invariant s.getLenRawSrcAddr() % 2 == 0
	invariant i % 2 == 0
	invariant 0 <= i && i <= s.getLenRawSrcAddr()
	// (joao) len(s.RawSrcAddr) replaced by s.getLenRawSrcAddr() to avoid unfoldings
	// for i := 0; i < len(s.RawSrcAddr); i += 2 {
	for i := 0; i < s.getLenRawSrcAddr(); i += 2 {
		// (joao) added parentheses surrounding s.RawSrcAddr, otherwise does not parse
		// (joao) original:
		// csum += uint32(s.RawSrcAddr[i]) << 8
		// csum += uint32(s.RawSrcAddr[i+1])
		// (joao) the following rewrite used to work before grouping permissions to s.RawSrcAddr in an instance of BytesAcc:
		// csum += uint32(unfolding acc(InvariantSCION(s), 1/400) in (s.RawSrcAddr)[i]) << 8
		// csum += uint32(unfolding acc(InvariantSCION(s), 1/400) in (s.RawSrcAddr)[i+1])
		csum += uint32(s.getRawSrcAddrIdx(i)) << 8
		csum += uint32(s.getRawSrcAddrIdx(i+1))
	}

	invariant acc(InvariantSCION(s), 1/200)
	invariant s.getLenRawDstAddr() % 2 == 0
	invariant i % 2 == 0
	invariant 0 <= i && i <= s.getLenRawDstAddr()
	// (joao) len(s.RawDstAddr) replaced by s.getLenRawSrcAddr() to avoid unfoldings
	// for i := 0; i < len(s.RawDstAddr); i += 2 {
	for i := 0; i < s.getLenRawDstAddr(); i += 2 {
		// (joao) added parentheses surrounding s.RawSrcAddr, otherwise does not parse
		// (joao) rewrite 1:
		// csum += uint32(unfolding acc(InvariantSCION(s), 1/400) in (s.RawDstAddr)[i]) << 8
		// csum += uint32(unfolding acc(InvariantSCION(s), 1/400) in (s.RawDstAddr)[i+1])
		csum += uint32(s.getRawDstAddrIdx(i)) << 8
		csum += uint32(s.getRawDstAddrIdx(i+1))
	}
	l := uint32(length)
	csum += (l >> 16) + (l & 0xffff)
	csum += uint32(protocol)
	return csum, nil
}

// (joao) Verified
requires len(srcIA) == 8 && len(dstIA) == 8
requires acc(InvariantSCION(s), 1/200)
requires forall i int :: 0 <= i && i < 8 ==> acc(&srcIA[i])
requires forall i int :: 0 <= i && i < 8 ==> acc(&dstIA[i])
ensures  acc(InvariantSCION(s), 1/200)
ensures  forall i int :: 0 <= i && i < 8 ==> acc(&srcIA[i])
ensures  forall i int :: 0 <= i && i < 8 ==> acc(&dstIA[i])
func (s *SCION) pseudoHeaderChecksumOutlineBlock1(srcIA []byte, dstIA []byte) {
	// (joao) Original code, omitted to avoid unfolding
	// s.SrcIA.Write(srcIA)
	(s.getSrcIA()).Write(srcIA)
	// (joao) Original code, omitted to avoid unfolding
	// s.DstIA.Write(dstIA)
	(s.getDstIA()).Write(srcIA)
}

// (joao) Verified
requires forall j int :: 0 <= j && j < len(upperLayer) ==> acc(&upperLayer[j], 1/10000)
ensures forall j int :: 0 <= j && j < len(upperLayer) ==> acc(&upperLayer[j], 1/10000)
func (s *SCION) upperLayerChecksum(upperLayer []byte, csum uint32) uint32 {
	// Compute safe boundary to ensure we do not access out of bounds.
	// Odd lengths are handled at the end.
	safeBoundary := len(upperLayer) - 1
	invariant safeBoundary == len(upperLayer) - 1
	invariant 0 <= i && i < safeBoundary + 2 && i % 2 == 0
	invariant forall j int :: 0 <= j && j < len(upperLayer) ==> acc(&upperLayer[j], 1/20000)
	for i := 0; i < safeBoundary; i += 2 {
		csum += uint32(upperLayer[i]) << 8
		csum += uint32(upperLayer[i+1])
	}
	if len(upperLayer)%2 == 1 {
		csum += uint32(upperLayer[safeBoundary]) << 8
	}
	return csum
}

// (joao) Verified
func (s *SCION) foldChecksum(csum uint32) uint16 {
	for csum > 0xffff {
		csum = (csum >> 16) + (csum & 0xffff)
	}
	return ^uint16(csum)
}