// Copyright 2020 Anapaya Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package slayers

import (
	"encoding/binary"
	// (joao) "fmt" package not supported yet
	// "fmt"
	"net"

	//"github.com/google/gopacket"
	"gobra/dependencies/gopacket"
	//"github.com/google/gopacket/layers"
	"gobra/dependencies/gopacket/layers"

	"gobra/lib/addr"
	"gobra/lib/common"
	"gobra/lib/serrors"
	//"github.com/scionproto/scion/go/lib/slayers/path/empty"
	"gobra/lib/slayers/path/empty"
	//"github.com/scionproto/scion/go/lib/slayers/path/onehop"
	"gobra/lib/slayers/path/onehop"
	//"github.com/scionproto/scion/go/lib/slayers/path/scion"
	"gobra/lib/slayers/path/scion"

	"gobra/verifyutils"
)

const (
	// LineLen is the length of a SCION header line in bytes.
	LineLen = 4
	// CmnHdrLen is the length of the SCION common header in bytes.
	CmnHdrLen = 12
	// SCIONVersion is the currently supported version of the SCION header format. Different
	// versions are not guaranteed to be compatible to each other.
	SCIONVersion = 0
)

// PathType indicates the type of the path contained in the SCION header.
type PathType uint8

// (joao) Hidden for performance
func (t PathType) String() string {
	switch t {
	case PathTypeEmpty:
		return "Empty (0)"
	case PathTypeSCION:
		return "SCION (1)"
	case PathTypeOneHop:
		return "OneHop (2)"
	case PathTypeEPIC:
		return "EPIC (3)"
	case PathTypeCOLIBRI:
		return "COLIBRI (4)"
	}
	// (joao) fmt.Sprintf not supported
	// return fmt.Sprintf("UNKNOWN (%d)", t)
	return verifyutils.HavocString()
}

// PathType constants
// (joao) used to be defined in terms of iota
const (
	PathTypeEmpty PathType = 0
	PathTypeSCION PathType = 1
	PathTypeOneHop PathType = 2
	PathTypeEPIC PathType = 3
	PathTypeCOLIBRI PathType = 4
)

// AddrLen indicates the length of a host address in the SCION header. The four possible lengths are
// 4, 8, 12, or 16 bytes.
type AddrLen uint8

// AddrLen constants
// (joao) used to be defined in terms of iota
const (
	AddrLen4 AddrLen = 0
	AddrLen8 AddrLen = 1
	AddrLen12 AddrLen = 2
	AddrLen16 AddrLen = 3
)
ghost const AddrLenError AddrLen = 4

ghost
pure func validAddrLen(addrLen AddrLen) bool {
	return addrLen == AddrLen4 || addrLen == AddrLen8 || addrLen == AddrLen12 || addrLen == AddrLen16
}

// AddrType indicates the type of a host address of a given length in the SCION header. There are
// four possible types per address length.
type AddrType uint8

// AddrType constants
// (joao) used to be defined in terms of iota
const (
	T4Ip AddrType = 0
	T4Svc AddrType = 1
)

// AddrLen16 types
// (joao) used to be defined in terms of iota
const (
	T16Ip AddrType = 0
)

// Path is the path contained in the SCION header.
type Path interface {
	// (joao) must hold for every receiver in the call of DecodeFromBytes. Represents
	//        permission to (possibly non initialized) memory that stores a Path
	pred UninitializedMem()
	// (joao) must hold in every valid instance of a Path
	pred Mem()
	// (joao) it should be possible to retrieve UninitializedMem() from Mem().
	//        this should be a ghost operation but ghost interface methods are currently not supported.
	requires Mem()
	ensures UninitializedMem()
	ExchangePerms()
	// SerializeTo serializes the path into the provided buffer.
	requires Mem() // (joao) there are implementations of this interface that modify the Path structure when serializing (e.g. scion.Raw)
	requires forall i int :: 0 <= i && i < len(b) ==> acc(&b[i])
	ensures  Mem()
	ensures  forall i int :: 0 <= i && i < len(b) ==> acc(&b[i])
	SerializeTo(b []byte) error
	// DecodesFromBytes decodes the path from the provided buffer.
	requires UninitializedMem()
 	// (joao) there are implementations of this interface (e.g. scion.Raw) that store b and use it as internal data
	requires forall i int :: 0 <= i && i < len(b) ==> acc(&b[i]) 
	ensures  res == nil ==> Mem()
	DecodeFromBytes(b []byte) (res error)
	// Reverse reverses a path such that it can be used in the reversed direction.
	//
	// XXX(shitz): This method should possibly be moved to a higher-level path manipulation package.
	requires Mem()
	ensures res == nil ==> Mem()
	Reverse() (res error)
	// Len returns the length of a path in bytes.
	requires acc(Mem(), _)
	pure Len() (ret int)
}

(empty.Path) implements Path {
	(x empty.Path) SerializeTo(b []byte) (err error) {
		unfold x.Mem()
		err = x.SerializeTo(b)
		fold x.Mem()
	}

	(x empty.Path) DecodeFromBytes(b []byte) (err error) {
		err = x.DecodeFromBytes(b)
		fold x.Mem()
	}

	(x empty.Path) Reverse() error {
		return x.Reverse()
	}

	pure (x empty.Path) Len() int {
		return x.Len()
	}

	(x empty.Path) ExchangePerms() {
		x.ExchangePerms()
	}
}

(*onehop.Path) implements Path {
	(x *onehop.Path) SerializeTo(b []byte) (err error) {
		err = x.SerializeTo(b)
	}

	(x *onehop.Path) DecodeFromBytes(b []byte) (err error) {
		err = x.DecodeFromBytes(b)
	}

	(x *onehop.Path) Reverse() error {
		return x.Reverse()
	}

	pure (x *onehop.Path) Len() int {
		return x.Len()
	}

	(x *onehop.Path) ExchangePerms() {
		x.ExchangePerms()
	}
}

pred UninitializedRaw(x *scion.Raw) {
	acc(&x.Base) && acc(&x.Raw)
}

(*scion.Raw) implements Path {

	pred UninitializedMem := UninitializedRaw

	(x *scion.Raw) SerializeTo(b []byte) (err error) {
		err = x.SerializeTo(b)
	}

	(x *scion.Raw) DecodeFromBytes(b []byte) (err error) {
		unfold UninitializedRaw(x)
		err = x.DecodeFromBytes(b)
	}

	(x *scion.Raw) Reverse() (err error) {
		err = x.Reverse()
	}

	pure (x *scion.Raw) Len() int {
		return unfolding acc(x.Mem(), _) in x.Len()
	}

	(x *scion.Raw) ExchangePerms() {
		x.ExchangePerms()
		fold UninitializedRaw(x)
	}
}

// SCION is the header of a SCION packet.
type SCION struct {
	// (joao) No support for embedded fields, added field EmbeddedBaseLayer instead
	// layers.BaseLayer
	EmbeddedBaseLayer layers.BaseLayer

	// Common Header fields

	// Version is version of the SCION Header. Currently, only 0 is supported.
	Version uint8
	// TrafficClass denotes the traffic class. Its value in a received packet or fragment might be
	// different from the value sent by the packet’s source. The current use of the Traffic Class
	// field for Differentiated Services and Explicit Congestion Notification is specified in
	// RFC2474 and RFC3168
	TrafficClass uint8
	// FlowID is a 20-bit field used by a source to label sequences of packets to be treated in the
	// network as a single flow. It is mandatory to be set.
	FlowID uint32
	// NextHdr  encodes the type of the first header after the SCION header. This can be either a
	// SCION extension or a layer-4 protocol such as TCP or UDP. Values of this field respect and
	// extend IANA’s assigned internet protocol numbers.
	NextHdr common.L4ProtocolType
	// HdrLen is the length of the SCION header in multiples of 4 bytes. The SCION header length is
	// computed as HdrLen * 4 bytes. The 8 bits of the HdrLen field limit the SCION header to a
	// maximum of 1024 bytes.
	HdrLen uint8
	// PayloadLen is the length of the payload in bytes. The payload includes extension headers and
	// the L4 payload. This field is 16 bits long, supporting a maximum payload size of 64KB.
	PayloadLen uint16

	// PathType specifies the type of path in this SCION header.
	PathType PathType

	// DstAddrType (2 bit) is the type of the destination address.
	DstAddrType AddrType
	// DstAddrLen (2 bit) is the length of the destination address. Supported address length are 4B
	// (0), 8B (1), 12B (2), and 16B (3).
	DstAddrLen AddrLen
	// SrcAddrType (2 bit) is the type of the source address.
	SrcAddrType AddrType
	// SrcAddrLen (2 bit) is the length of the source address. Supported address length are 4B (0),
	// 8B (1), 12B (2), and 16B (3).
	SrcAddrLen AddrLen

	// Address header fields.

	// DstIA is the destination ISD-AS.
	DstIA addr.IA
	// SrcIA is the source ISD-AS.
	SrcIA addr.IA
	// RawDstAddr is the destination address.
	RawDstAddr []byte
	// RawSrcAddr is the source address.
	RawSrcAddr []byte

	// Path is the path contained in the SCION header. It depends on the PathType field.
	Path Path

	// start of ghost members

	/* ghost */
	RawPkt []byte
}

pred (s *SCION) Mem() {
	acc(s) &&
	verifyutils.BytesAcc(s.RawSrcAddr) &&
	verifyutils.BytesAcc(s.RawDstAddr) &&
	validAddrLen(s.SrcAddrLen) && len(s.RawSrcAddr) == addrBytes(s.SrcAddrLen) && len(s.RawSrcAddr)%2 == 0 &&
	validAddrLen(s.DstAddrLen) && len(s.RawDstAddr) == addrBytes(s.DstAddrLen) && len(s.RawDstAddr)%2 == 0 &&
	s.Path.Mem() &&
	// value of uint fields is non-negative (Gobra cannot prove this yet)
	s.Version >= 0 &&
	s.TrafficClass >= 0 &&
	s.FlowID >= 0 &&
	s.HdrLen >= 0 &&
	s.PayloadLen >= 0 &&
	// ghost
	verifyutils.BytesAcc(s.RawPkt)
	// TODO:
	// - Relation between PathType and Path
}

ghost
requires s.Mem()
requires verifyutils.ByteSlicesEqual(rawPkt, s.getRawPkt())
ensures verifyutils.BytesAcc(rawPkt)
ensures verifyutils.BytesAcc(rawPkt) --* (s.Mem() && verifyutils.ByteSlicesEqual(rawPkt, s.getRawPkt()))
func (s *SCION) getRawPktAcc(rawPkt []byte) //{
// 	unfold verifyutils.ByteSlicesEqual(rawPkt, s.getRawPkt())
// 	unfold s.Mem()
// 	package verifyutils.BytesAcc(rawPkt) --* s.Mem() {
// 		fold s.Mem()
// 	}
// }


ghost 
requires s.Mem()
ensures p.Mem()
ensures p.Mem() --* s.Mem()
func (s *SCION) getPathAcc() (ghost p Path) {
	unfold s.Mem()
	p := s.Path
	package p.Mem() --* s.Mem() {
		fold s.Mem()
	}
}

/*
// (joao) Fails, as expected
ghost
requires s.Mem()
func soundInvariantSCION1(s *SCION) {
	unfold s.Mem()
	assert false
}
*/

/*
(*SCION) implements gopacket.SerializableLayer {
	pure (s *SCION) LayerType() gopacket.LayerType {
		return s.LayerType()
	} 

	(s *SCION) SerializeTo(b gopacket.SerializeBuffer, opts gopacket.SerializeOptions) (err error) {
		err = s.SerializeTo(b, opts)
	}
}
*/

/** Getters **/
// (joao) As suggested in Sascha's thesis, we extracted getters that require unfoldings to
//        occur in their own pure functions.

pure
requires acc(s.Mem(), 1/1000)
func (s *SCION) getDstAddrType() AddrType {
	return unfolding acc(s.Mem(), 1/1000) in s.DstAddrType
}

pure
requires acc(s.Mem(), 1/1000)
func (s *SCION) getSrcAddrType() AddrType {
	return unfolding acc(s.Mem(), 1/1000) in s.SrcAddrType
}

pure
requires acc(s.Mem(), 1/1000)
func (s *SCION) getVersion() uint8 {
	return unfolding acc(s.Mem(), 1/1000) in s.Version
}

pure
requires acc(s.Mem(), 1/1000)
func (s *SCION) getTrafficClass() uint8 {
	return unfolding acc(s.Mem(), 1/1000) in s.TrafficClass
}

pure
requires acc(s.Mem(), 1/1000)
func (s *SCION) getFlowID() uint32 {
	return unfolding acc(s.Mem(), 1/1000) in s.FlowID
}

pure
requires acc(s.Mem(), 1/1000)
func (s *SCION) getNextHdr() common.L4ProtocolType {
	return unfolding acc(s.Mem(), 1/1000) in s.NextHdr
}

pure
requires acc(s.Mem(), 1/1000)
func (s *SCION) getHdrLen() uint8 {
	return unfolding acc(s.Mem(), 1/1000) in s.HdrLen
}

pure
requires acc(s.Mem(), 1/1000)
func (s *SCION) getPayloadLen() uint16 {
	return unfolding acc(s.Mem(), 1/1000) in s.PayloadLen
}

pure
requires acc(s.Mem(), 1/1000)
func (s *SCION) getRawSrcAddr() []byte {
	return unfolding acc(s.Mem(), 1/1000) in s.RawSrcAddr
}

pure
requires acc(s.Mem(), 1/1000)
func (s *SCION) getPathType() PathType {
	return unfolding acc(s.Mem(), 1/1000) in s.PathType
}

pure
requires acc(s.Mem(), _)
requires 0 <= i && i < s.getLenRawSrcAddr()
func (s *SCION) getRawSrcAddrIdx(i int) (res byte) {
	return unfolding acc(s.Mem(), _) in verifyutils.BytesIndex(s.RawSrcAddr, i)
}

pure
requires acc(s.Mem(), _)
requires 0 <= i && i < s.getLenRawDstAddr()
func (s *SCION) getRawDstAddrIdx(i int) (res byte) {
	return unfolding acc(s.Mem(), _) in verifyutils.BytesIndex(s.RawDstAddr, i)
}

pure
requires acc(s.Mem(), _)
func (s *SCION) getDstAddrLen() AddrLen {
	return unfolding acc(s.Mem(), _) in s.DstAddrLen
}

pure
requires acc(s.Mem(), _)
func (s *SCION) getSrcAddrLen() AddrLen {
	return unfolding acc(s.Mem(), _) in s.SrcAddrLen
}

pure
requires acc(s.Mem(), _)
ensures res == unfolding acc(s.Mem(), _) in len(s.RawSrcAddr)
ensures res%2 == 0
func (s *SCION) getLenRawSrcAddr() (res int) {
	return unfolding acc(s.Mem(), _) in len(s.RawSrcAddr)
}

pure
requires acc(s.Mem(), _)
func (s *SCION) getRawDstAddr() []byte {
	return unfolding acc(s.Mem(), _) in s.RawDstAddr
}

pure
requires acc(s.Mem(), _)
ensures res == unfolding acc(s.Mem(), _) in len(s.RawDstAddr)
ensures res%2 == 0
func (s *SCION) getLenRawDstAddr() (res int) {
	return unfolding acc(s.Mem(), _) in len(s.RawDstAddr)
}

pure
requires acc(s.Mem(), _)
func (s *SCION) getDstIA() addr.IA {
	return unfolding acc(s.Mem(), _) in s.DstIA
}

pure
requires acc(s.Mem(), _)
func (s *SCION) getSrcIA() addr.IA {
	return unfolding acc(s.Mem(), _) in s.SrcIA
}

pure
requires acc(s.Mem(), _)
func (s *SCION) getRawPkt() (res []byte) {
	return unfolding acc(s.Mem(), _) in s.RawPkt
}

pure
requires acc(s.Mem(), _)
func (s *SCION) getPath() (res Path) {
	return unfolding acc(s.Mem(), _) in s.Path
}

ghost
pure
requires acc(s.Mem(), _)
func (s *SCION) getRawScionPath() *scion.Raw {
	return unfolding acc(s.Mem(), _) in typeOf(s.Path) == *scion.Raw ? (s.Path).(*scion.Raw) : (*scion.Raw)(nil)
}
/** End of Getters **/

ensures res == (int(addrLen) + 1) * LineLen
ensures addrLen == AddrLen4 ==> res == 4
ensures addrLen == AddrLen8 ==> res == 8
ensures addrLen == AddrLen12 ==> res == 12
ensures addrLen == AddrLen16 ==> res == 16
ensures res%2 == 0
pure func addrBytes(addrLen AddrLen) (res int) {
	return (int(addrLen) + 1) * LineLen
}

pure
func (s *SCION) LayerType() gopacket.LayerType {
	// (joao) slayers.LayerTypeSCION is currently implemented as a pure function due to the lack of support for global variables
	// return LayerTypeSCION
	return LayerTypeSCION()
}

/* pure */
// (joao) LayerClass not implemented
// func (s *SCION) CanDecode() gopacket.LayerClass {
//	return LayerTypeSCION
//}

requires acc(s.Mem(), 1/100)
func (s *SCION) NextLayerType() gopacket.LayerType {
	// return scionNextLayerType(s.NextHdr)
	return scionNextLayerType(s.getNextHdr())
}

// (joao) This does not grant permissions to the returned slice.
//        This is useful if one only wants to compute the length of the returned slice.
pure
requires acc(s.Mem(), 1/10000)
func (s *SCION) LayerPayload() []byte {
	// (joao) the field `Payload` is implemented in the embedded field `layers.BaseLayer`.
	// (joao) embedded fields are broken.
	// return s.Payload
	return unfolding acc(s.Mem(), 1/10000) in (s.EmbeddedBaseLayer).Payload
}

// (tlino) give up access to s to get access to Payload
// (tlino) TODO implement method
requires s.Mem()
ensures forall i int :: 0 <= i && i < len(b) ==> acc(&b[i])
func (s *SCION) LayerPayloadWithPermission() (b []byte) //{
// 	unfold s.Mem()
// 	return (s.EmbeddedBaseLayer).Payload
// }

// (tlino) give up access to s to get access to Payload and Path
// (tlino) TODO implement method
requires s.Mem()
ensures forall i int :: 0 <= i && i < len(b) ==> acc(&b[i])
ensures p.Mem()
func (s *SCION) GetPathAndPayload() (p Path, b []byte) //{
// 	unfold s.Mem()
// 	return s.Path, (s.EmbeddedBaseLayer).Payload
// }

// (joao) Flow not implemented
//func (s *SCION) NetworkFlow() gopacket.Flow {
//	// TODO(shitz): Investigate how we can use gopacket.Flow.
//	return gopacket.Flow{}
//}

requires acc(s.Mem(), 1/1000)
ensures  ret == unfolding acc(s.Mem(), 1/100) in s.Path.Len()
ensures  ret >= 0 // (joao) This cannot be added as a post-condition of the pure method in Path and is also not inferred from the instances
pure func (s *SCION) getPathLen() (ret int) /* {
	return unfolding acc(s.Mem(), 1/100) in s.Path.Len()
}
*/

// (joao) Partially Verified
requires s.Mem() && b.Mem()
ensures retErr == nil ==> s.Mem() && b.Mem() && verifyutils.ByteSlicesEqual(old(s.getRawPkt()), s.getRawPkt())
func (s *SCION) SerializeTo(b gopacket.SerializeBuffer, opts gopacket.SerializeOptions) (retErr error) {
	scnLen := CmnHdrLen + s.AddrHdrLen() + s.getPathLen()
	buf, err := b.PrependBytes(scnLen)
	if err != nil {
		return err
	}
	// (joao) verify after adding support for magic wands
	// (joao) this is safe but not proved atm. Verifying this requires introducing
	//        a new pure function that returns the value of Bytes() and then proving that
	//        Bytes() returns that value and permissions to the elements, and introduce a new variant
	//        that does not give access to the elements of the slice and can be called when there is permission to b.PrependBytesMem()
	// if opts.FixLengths {
	// 	s.HdrLen = uint8(scnLen / LineLen)
	// 	s.PayloadLen = uint16(len(b.Bytes()) - int(scnLen))
	// }

	// Serialize common header.
	// (joao) rewrote the following
	// firstLine := uint32(s.Version&0xF)<<28 | uint32(s.TrafficClass)<<20 | s.FlowID&0xFFFFF
	firstLine := uint32(s.getVersion()&0xF)<<28 | uint32(s.getTrafficClass())<<20 | s.getFlowID()&0xFFFFF
	unfold verifyutils.BytesAcc(buf)
	assert &buf[:4][0] == &buf[0]
	assert &buf[:4][1] == &buf[1]
	assert &buf[:4][2] == &buf[2]
	assert &buf[:4][3] == &buf[3]
	binary.BigEndian.PutUint32(buf[:4], firstLine)
	// (joao) rewrote the following:
	// buf[4] = uint8(s.NextHdr)
	// buf[5] = s.HdrLen
	// binary.BigEndian.PutUint16(buf[6:8], s.PayloadLen)
	// buf[8] = uint8(s.PathType)
	buf[4] = uint8(s.getNextHdr())
	buf[5] = s.getHdrLen()
	assert &buf[6:8][0] == &buf[6]
	assert &buf[6:8][1] == &buf[7]
	binary.BigEndian.PutUint16(buf[6:8], s.getPayloadLen())
	buf[8] = uint8(s.getPathType())
	
	// (joao) changed from field access to pure function call
	// buf[9] = uint8(s.DstAddrType&0x3)<<6 | uint8(s.DstAddrLen&0x3)<<4 |
	//	uint8(s.SrcAddrType&0x3)<<2 | uint8(s.SrcAddrLen&0x3)
	buf[9] = uint8(s.getDstAddrType()&0x3)<<6 | uint8(s.getDstAddrLen()&0x3)<<4 |
		uint8(s.getSrcAddrType()&0x3)<<2 | uint8(s.getSrcAddrLen()&0x3)
	assert &buf[10:12][0] == &buf[10]
	assert &buf[10:12][1] == &buf[11]
	binary.BigEndian.PutUint16(buf[10:12], 0)

	// Serialize address header.
	assert len(buf) >= CmnHdrLen
	assert forall i int :: 0 <= i && i < len(buf[CmnHdrLen:]) ==> &(buf[CmnHdrLen:])[i] == &buf[CmnHdrLen + i]
	if err := s.SerializeAddrHdr(buf[CmnHdrLen:]); err != nil {
		return err
	}
	offset := CmnHdrLen + s.AddrHdrLen()
	// Serialize path header.
	// (joao) outlined the following call
	// return s.Path.SerializeTo(buf[offset:])
	assert forall i int :: 0 <= i && i < len(buf[offset:]) ==> &(buf[offset:])[i] == &buf[i + offset]
	var ret error = s.outlinePathSerializeTo(buf[offset:])
	fold verifyutils.BytesAcc(buf)
	apply verifyutils.BytesAcc(buf) --* b.Mem()
}

preserves s.Mem()
preserves forall i int :: 0 <= i && i < len(buf) ==> acc(&buf[i])
ensures verifyutils.ByteSlicesEqual(old(s.getRawPkt()), s.getRawPkt())
func (s *SCION) outlinePathSerializeTo(buf []byte) error /*{
	unfold s.Mem()
	ret := s.Path.SerializeTo(buf)
	fold s.Mem()
	return ret
}
*/

// (joao) Assumed for now
// DecodeFromBytes decodes the SCION layer. DecodeFromBytes resets the internal state of this layer
// to the state defined by the passed-in bytes. Slices in the SCION layer reference the passed-in
// data, so care should be taken to copy it first should later modification of data be required
// before the SCION layer is discarded.
requires acc(s) && df.Mem()
requires forall i int :: 0 <= i && i < len(data) ==> acc(&data[i])
ensures  df.Mem()
ensures  errRes == nil ==> s.Mem()
func (s *SCION) DecodeFromBytes(data []byte, df gopacket.DecodeFeedback) (errRes error) /* {
	// Decode common header.
	if len(data) < CmnHdrLen {
		df.SetTruncated()
		return serrors.New("packet is shorter than the common header length",
			"min", CmnHdrLen, "actual", len(data))
	}
	firstLine := binary.BigEndian.Uint32(data[:4])
	s.Version = uint8(firstLine >> 28)
	s.TrafficClass = uint8((firstLine >> 20) & 0xFF)
	s.FlowID = firstLine & 0xFFFFF
	s.NextHdr = common.L4ProtocolType(data[4])
	s.HdrLen = data[5]
	s.PayloadLen = binary.BigEndian.Uint16(data[6:8])
	s.PathType = PathType(data[8])
	s.DstAddrType = AddrType(data[9] >> 6)
	s.DstAddrLen = AddrLen(data[9] >> 4 & 0x3)
	s.SrcAddrType = AddrType(data[9] >> 2 & 0x3)
	s.SrcAddrLen = AddrLen(data[9] & 0x3)

	// Decode address header.
	if err := s.DecodeAddrHdr(data[CmnHdrLen:]); err != nil {
		df.SetTruncated()
		return err
	}
	addrHdrLen := s.AddrHdrLen()
	offset := CmnHdrLen + addrHdrLen

	// Decode path header.
	var err error
	hdrBytes := int(s.HdrLen) * LineLen
	pathLen := hdrBytes - CmnHdrLen - addrHdrLen
	if pathLen < 0 {
		return serrors.New("invalid header, negative pathLen",
			"hdrBytes", hdrBytes, "addrHdrLen", addrHdrLen, "CmdHdrLen", CmnHdrLen)
	}

	switch s.PathType {
	case PathTypeEmpty:
		if _, ok := s.Path.(empty.Path); ok {
			break
		}
		s.Path = empty.Path{}
		if pathLen != 0 {
			return serrors.New("invalid header, non-empty empty path", "hdrBytes", hdrBytes,
				"addrHdrLen", addrHdrLen, "CmdHdrLen", CmnHdrLen, "pathLen", pathLen)
		}
	case PathTypeSCION:
		// Only allocate a SCION path if necessary. This reduces memory allocation and GC overhead
		// considerably (3x improvement for DecodeFromBytes performance)
		if _, ok := s.Path.(*scion.Raw); ok {
			break
		}
		s.Path = &scion.Raw{}
	case PathTypeOneHop:
		if _, ok := s.Path.(*onehop.Path); ok {
			break
		}
		s.Path = &onehop.Path{}
	case PathTypeEPIC, PathTypeCOLIBRI:
		return serrors.New("unsupported path type", "type", s.PathType.String())
	default:
		return serrors.New("unknown path type", "type", s.PathType.String())
	}

	if minLen := offset + pathLen; len(data) < minLen {
		df.SetTruncated()
		return serrors.New("provided buffer is too small", "expected", minLen, "actual", len(data))
	}
	err = s.Path.DecodeFromBytes(data[offset : offset+pathLen])
	if err != nil {
		return err
	}
	s.Contents = data[:hdrBytes]
	s.Payload = data[hdrBytes:]

	// (tlino) store data in ghost field
	s.RawPkt = data

	return nil
}
*/


// (joao) ignored for now, not used in this file
/* func decodeSCION(data []byte, pb gopacket.PacketBuilder) error {
	scn := &SCION{}
	err := scn.DecodeFromBytes(data, pb)
	if err != nil {
		return err
	}
	pb.AddLayer(scn)
	pb.SetNetworkLayer(scn)
	return pb.NextDecoder(scionNextLayerType(scn.NextHdr))
}
*/

// (joao) global variables still not supported
func scionNextLayerType(t common.L4ProtocolType) gopacket.LayerType {
	switch t {
	case common.L4UDP:
		// return LayerTypeSCIONUDP
		return LayerTypeSCIONUDP()
	case common.L4SCMP:
		// return LayerTypeSCMP
		return LayerTypeSCMP()
	case common.L4BFD:
		// return layers.LayerTypeBFD
		return layers.LayerTypeBFD()
	case common.HopByHopClass:
		// return LayerTypeHopByHopExtn
		return LayerTypeHopByHopExtn()
	case common.End2EndClass:
		// return LayerTypeEndToEndExtn
		return LayerTypeEndToEndExtn()
	default:
		// return gopacket.LayerTypePayload
		return gopacket.LayerTypePayload()
	}
}

// (joao) The following predicate and ghost function would not be necessary
//        if Gobra had support for magic wands 
pred (s *SCION) ReadDstAddr(addr net.Addr)

ghost
requires acc(s.Mem(), 1/200) && acc(addr.Mem(), 1/200)
requires s.ReadDstAddr(addr)
ensures acc(s.Mem(), 1/100)
func (s *SCION) AddReadDstAddr(addr net.Addr)

// (joao) Verified
// DstAddr parses the destination address into a net.Addr. The returned net.Addr references data
// from the underlaying layer data. Changing the net.Addr object might lead to inconsistent layer
// information and thus should be treated read-only. Instead, SetDstAddr should be used to update
// the destination address.
requires acc(s.Mem(), 1/200)
ensures resErr == nil ==> acc(resAddr.Mem(), 1/200) && s.ReadDstAddr(resAddr)
func (s *SCION) DstAddr() (resAddr net.Addr, resErr error) {
	unfold acc(s.Mem(), 1/200)
	// (joao) this call used to be part of the return statement
	res, err := parseAddr(s.DstAddrType, s.DstAddrLen, s.RawDstAddr)
	inhale err == nil ==> s.ReadDstAddr(res)
	return res, err
}

// (joao) The following predicate and ghost function would not be necessary
//        if Gobra had support for magic wands 
pred (s *SCION) ReadSrcAddr(addr net.Addr)

ghost
requires acc(s.Mem(), 1/200) && acc(addr.Mem(), 1/200)
requires s.ReadSrcAddr(addr)
ensures acc(s.Mem(), 1/100)
func (s *SCION) AddReadSrcAddr(addr net.Addr)

// (joao) Verified
// SrcAddr parses the source address into a net.Addr. The returned net.Addr references data from the
// underlaying layer data. Changing the net.Addr object might lead to inconsistent layer information
// and thus should be treated read-only. Instead, SetDstAddr should be used to update the source
// address.
requires acc(s.Mem(), 1/200)
ensures resErr == nil ==> acc(resAddr.Mem(), 1/200) && s.ReadSrcAddr(resAddr)
func (s *SCION) SrcAddr() (resAddr net.Addr, resErr error) {
	unfold acc(s.Mem(), 1/200)
	// (joao) this call used to be part of the return statement
	res, err := parseAddr(s.SrcAddrType, s.SrcAddrLen, s.RawSrcAddr)
	inhale err == nil ==> s.ReadSrcAddr(res)
	return res, err
}

// (joao) Verified
// SetDstAddr sets the destination address and updates the DstAddrLen/Type fields accordingly.
// SetDstAddr takes ownership of dst and callers should not write to it after calling SetDstAddr.
// Changes to dst might leave the layer in an inconsistent state.
requires s.Mem() && dst.Mem()
ensures ret == nil ==> s.Mem()
func (s *SCION) SetDstAddr(dst net.Addr) (ret error) {
	unfold s.Mem()
	var err error
	s.DstAddrLen, s.DstAddrType, s.RawDstAddr, err = packAddr(dst)
	ghost if err == nil {
		assert validAddrLen(s.SrcAddrLen) && len(s.RawSrcAddr) == addrBytes(s.SrcAddrLen)
		assert validAddrLen(s.DstAddrLen) && len(s.RawDstAddr) == addrBytes(s.DstAddrLen)
		assert verifyutils.BytesAcc(s.RawSrcAddr) 
		assert verifyutils.BytesAcc(s.RawDstAddr) 
		fold s.Mem()
	}
	return err
}

// SetSrcAddr sets the source address and updates the DstAddrLen/Type fields accordingly.
// SetSrcAddr takes ownership of src and callers should not write to it after calling SetSrcAddr.
// Changes to src might leave the layer in an inconsistent state.
// (joao) Verified
requires s.Mem() && src.Mem()
ensures ret == nil ==> s.Mem()
func (s *SCION) SetSrcAddr(src net.Addr) (ret error) {
	var err error
	unfold s.Mem()
	s.SrcAddrLen, s.SrcAddrType, s.RawSrcAddr, err = packAddr(src)
	ghost if err == nil {
		assert validAddrLen(s.SrcAddrLen) && len(s.RawSrcAddr) == addrBytes(s.SrcAddrLen)
		assert validAddrLen(s.DstAddrLen) && len(s.RawDstAddr) == addrBytes(s.DstAddrLen)
		assert verifyutils.BytesAcc(s.RawSrcAddr) 
		assert verifyutils.BytesAcc(s.RawDstAddr) 
		fold s.Mem()
	}
	return err
}

requires addrLen == AddrLen4 ==> len(raw) == 4
requires addrLen == AddrLen16 ==> len(raw) == 16
requires acc(verifyutils.BytesAcc(raw), 1/200)
ensures addrLen != AddrLen4 && addrLen != AddrLen16 ==> resErr != nil
ensures (addrLen == AddrLen4 && (addrType == T4Ip || addrType == T4Svc)) ==> resErr == nil
ensures (addrLen == AddrLen16 && addrType == T16Ip) ==> resErr == nil
ensures resErr == nil ==> acc(resAddr.Mem(), 1/200)
func parseAddr(addrType AddrType, addrLen AddrLen, raw []byte) (resAddr net.Addr, resErr error) {
	switch addrLen {
	case AddrLen4:
		switch addrType {
		case T4Ip:
			// (joao) previously:
			// return &net.IPAddr{IP: net.IP(raw)}, nil
			unfold acc(verifyutils.BytesAcc(raw), 1/200)
			tmp := &net.IPAddr{IP: net.IP(raw)}
			fold acc(tmp.Mem(), 1/200)
			return tmp, nil
		case T4Svc:
			// (joao) previously:
			// return addr.HostSVC(binary.BigEndian.Uint16(raw[:addr.HostLenSVC])), nil
			unfold acc(verifyutils.BytesAcc(raw), 1/200)
			assert forall i int :: 0 <= i && i < addr.HostLenSVC ==> &raw[:addr.HostLenSVC][i] == &raw[i]
			tmp := addr.HostSVC(binary.BigEndian.Uint16(raw[:addr.HostLenSVC]))
			fold acc(tmp.Mem(), 1/200)
			return tmp, nil
		}
	case AddrLen16:
		switch addrType {
		case T16Ip:
			// (joao) previously:
			// return &net.IPAddr{IP: net.IP(raw)}, nil
			unfold acc(verifyutils.BytesAcc(raw), 1/200)
			tmp := &net.IPAddr{IP: net.IP(raw)}
			fold acc(tmp.Mem(), 1/200)
			return tmp, nil
		}
	}
	return nil, serrors.New("unsupported address type/length combination",
		"type", addrType, "len", addrLen)
}

// (joao) Assumed
// (joao) Verify this next
// (joao) requires implementation proof that IPAddr implements Addr to verify the body
requires hostAddr.Mem()
ensures verifyutils.BytesAcc(s)
// (joao) the LHS of this implication is necessary, because AddrLen4 is 0 and 0 is the value returned for addrLen
//        in case of error
ensures (err == nil && addrLen == AddrLen4)  ==> (addrType == T4Svc || addrType == T4Ip)
ensures (err == nil && addrLen == AddrLen16) ==> addrType == T16Ip
// (joao) This post-condition may require additional-checks to hold 
ensures err == nil ==> validAddrLen(addrLen) && len(s) == addrBytes(addrLen)
ensures err != nil ==> addrLen == 0 && addrType == 0 && s == nil
func packAddr(hostAddr net.Addr) (addrLen AddrLen, addrType AddrType, s []byte, err error) /* {
	switch a := hostAddr.(type) {
	case *net.IPAddr:
		if ip := a.IP.To4(); ip != nil {
			return AddrLen4, T4Ip, ip, nil
		}
		// (joao) requires ip.Mem() to make it succeed
		return AddrLen16, T16Ip, a.IP, nil
	case addr.HostSVC:
		return AddrLen4, T4Svc, a.PackWithPad(2), nil
	}
	return 0, 0, nil, serrors.New("unsupported address", "addr", hostAddr)
}
*/

// AddrHdrLen returns the length of the address header (destination and source ISD-AS-Host triples)
// in bytes.
requires acc(s.Mem(), _)
ensures unfolding acc(s.Mem(), _) in res == 2*addr.IABytes + addrBytes(s.DstAddrLen) + addrBytes(s.SrcAddrLen)
ensures unfolding acc(s.Mem(), _) in addrBytes(s.DstAddrLen) >= 0
ensures unfolding acc(s.Mem(), _) in addrBytes(s.SrcAddrLen) >= 0
pure func (s *SCION) AddrHdrLen() (res int) {
	return unfolding s.Mem() in 2*addr.IABytes + addrBytes(s.DstAddrLen) + addrBytes(s.SrcAddrLen)
}

// (joao) Verified
// SerializeAddrHdr serializes destination and source ISD-AS-Host address triples into the provided
// buffer. The caller must ensure that the correct address types and lengths are set in the SCION
// layer, otherwise the results of this method are undefined.
preserves acc(s.Mem(), 1/100)
preserves forall i int :: 0 <= i && i < len(buf) ==> acc(&buf[i])
ensures err == nil ==> verifyutils.ByteSlicesEqual(old(s.getRawPkt()), s.getRawPkt())
ensures len(buf) >= s.AddrHdrLen() ==> err == nil
ensures len(buf) < s.AddrHdrLen()  ==> err != nil
func (s *SCION) SerializeAddrHdr(buf []byte) (err error) {
	if len(buf) < s.AddrHdrLen() {
		return serrors.New("provided buffer is too small", "expected", s.AddrHdrLen(),
			"actual", len(buf))
	}
	// (joao) rewrote the following
	// dstAddrBytes := addrBytes(s.DstAddrLen)
	// srcAddrBytes := addrBytes(s.SrcAddrLen)
	dstAddrBytes := addrBytes(s.getDstAddrLen())
	srcAddrBytes := addrBytes(s.getSrcAddrLen())
	offset := 0
	assert len(buf) == len(buf[offset:])
	assert forall i int :: 0 <= i && i < len(buf) ==> &buf[i] == &(buf[offset:][i])
	// (joao) rewrote the following
	// s.DstIA.Write(buf[offset:])
	(s.getDstIA()).Write(buf[offset:])
	offset += addr.IABytes
	assert len(buf) == len(buf[offset:]) + offset
	assert forall i int :: 0 <= i && i < len(buf[offset:]) ==> &buf[i + offset] == &(buf[offset:][i])
	// (joao) rewrote the following
	// s.SrcIA.Write(buf[offset:])
	(s.getSrcIA()).Write(buf[offset:])
	offset += addr.IABytes
	assert offset <= len(buf)
	assert offset + dstAddrBytes <= len(buf)
	assert forall i int :: 0 <= i && i < len(buf[offset:offset+dstAddrBytes]) ==> &buf[i + offset] == &(buf[offset:offset+dstAddrBytes][i])
	// (joao) Outlined call to copy
	// copy(buf[offset:offset+dstAddrBytes], s.RawDstAddr)
	copyRawDstAddr(s, buf[offset:offset+dstAddrBytes])
	offset += dstAddrBytes
	assert offset <= len(buf)
	assert offset + srcAddrBytes <= len(buf)
	assert forall i int :: 0 <= i && i < len(buf[offset:offset+srcAddrBytes]) ==> &buf[i + offset] == &(buf[offset:offset+srcAddrBytes][i])
	// (joao) Outlined call to copy
	// copy(buf[offset:offset+srcAddrBytes], s.RawSrcAddr)
	copyRawSrcAddr(s, buf[offset:offset+srcAddrBytes])
	return nil
}

// (joao) Assumed
// (joao) function not present in the original code
preserves acc(s.Mem(), 1/1000)
preserves forall i int :: 0 <= i && i < len(b) ==> acc(&b[i])
ensures verifyutils.ByteSlicesEqual(old(s.getRawPkt()), s.getRawPkt())
func copyRawDstAddr(s *SCION, b []byte) /* {
	// (joao) without this assumption, verification does not terminate
	assume false
	unfold acc(s.Mem(), 1/1000)
	unfold acc(verifyutils.BytesAcc(s.RawDstAddr), 1/10000)
	verifyutils.OutlineMemorySafeCopy(b, s.RawDstAddr)
	assume false
	fold acc(verifyutils.BytesAcc(s.RawDstAddr), 1/10000)
	fold acc(s.Mem(), 1/1000)
}
*/

// (joao) Assumed
// (joao) function not present in the original code
preserves acc(s.Mem(), 1/1000)
preserves forall i int :: 0 <= i && i < len(b) ==> acc(&b[i])
ensures verifyutils.ByteSlicesEqual(old(s.getRawPkt()), s.getRawPkt())
func copyRawSrcAddr(s *SCION, b []byte) /* {
	// (joao) without this assumption, verification does not terminate
	assume false
	unfold acc(s.Mem(), 1/1000)
	unfold acc(verifyutils.BytesAcc(s.RawSrcAddr), 1/10000)
	verifyutils.OutlineMemorySafeCopy(b, s.RawSrcAddr)
	fold acc(verifyutils.BytesAcc(s.RawSrcAddr), 1/10000)
	fold acc(s.Mem(), 1/1000)
}
*/

// (joao) TODO: remake this spec
// (joao) Assumed for now
// DecodeAddrHdr decodes the destination and source ISD-AS-Host address triples from the provided
// buffer. The caller must ensure that the correct address types and lengths are set in the SCION
// layer, otherwise the results of this method are undefined.
requires acc(s) && validAddrLen(s.SrcAddrLen) && validAddrLen(s.DstAddrLen)
requires forall i int :: 0 <= i && i < len(data) ==> acc(&data[i])
ensures  acc(s) && validAddrLen(s.SrcAddrLen) && validAddrLen(s.DstAddrLen)
// (joao) uncommenting the following post-condition increases verification time from ~4min to ~26
// ensures  res == nil ==> (verifyutils.BytesAcc(s.RawSrcAddr) && verifyutils.BytesAcc(s.RawDstAddr) && validSrcAddr(s) && validDstAddr(s))
func (s *SCION) DecodeAddrHdr(data []byte) (res error) /* {
	assert addrBytes(s.DstAddrLen) >= 0
	assert addrBytes(s.SrcAddrLen) >= 0
	// (joao) inline calls to s.AddrHdrLen due to missing s.Mem() permission
	// if len(data) < s.AddrHdrLen() {
	//	return serrors.New("provided buffer is too small", "expected", s.AddrHdrLen(),
	//		"actual", len(data))
	//}
	if len(data) < 2*addr.IABytes + addrBytes(s.DstAddrLen) + addrBytes(s.SrcAddrLen) {
		return serrors.New("provided buffer is too small", "expected", 2*addr.IABytes + addrBytes(s.DstAddrLen) + addrBytes(s.SrcAddrLen),
			"actual", len(data))
	}
	assume false
	offset := 0
	unfold s.Mem()
	assert len(data[offset:]) == len(data)
	assert forall i int :: 0 <= i && i < len(data[offset:]) ==> &(data[offset:])[i] == &data[offset + i]
	s.DstIA = addr.IAFromRaw(data[offset:])
	offset += addr.IABytes
	assert len(data[offset:]) == len(data) - offset
	assert forall i int :: 0 <= i && i < len(data[offset:]) ==> &(data[offset:])[i] == &data[offset + i]
	s.SrcIA = addr.IAFromRaw(data[offset:])
	offset += addr.IABytes
	dstAddrBytes := addrBytes(s.DstAddrLen)
	srcAddrBytes := addrBytes(s.SrcAddrLen)
	assert len(data) >= 2 * addr.IABytes + srcAddrBytes + dstAddrBytes
	assume false
	assert len(data[offset:]) == len(data) - offset
	assert forall i int :: 0 <= i && i < len(data[offset:]) ==> &(data[offset:])[i] == &data[offset + i]
	s.RawDstAddr = data[offset : offset+dstAddrBytes]
	offset += dstAddrBytes
	assert len(data[offset:]) == len(data) - offset
	assert forall i int :: 0 <= i && i < len(data[offset:]) ==> &(data[offset:])[i] == &data[offset + i]
	s.RawSrcAddr = data[offset : offset+srcAddrBytes]
	return nil
}
*/

// (joao) Verified
// computeChecksum computes the checksum with the SCION pseudo header.
preserves s != nil ==> acc(s.Mem(), 1/100)
preserves forall j int :: 0 <= j && j < len(upperLayer) ==> acc(&upperLayer[j], 1/10000)
ensures retErr != nil ==> ret == 0
ensures s == nil ==> retErr != nil
ensures s != nil && s.getLenRawSrcAddr() > 0 && s.getLenRawDstAddr() > 0 ==> retErr == nil
func (s *SCION) computeChecksum(upperLayer []byte, protocol uint8) (ret uint16, retErr error) {
	if s == nil {
		return 0, serrors.New("SCION header missing")
	}
	csum, err := s.pseudoHeaderChecksum(len(upperLayer), protocol)
	if err != nil {
		return 0, err
	}
	csum = s.upperLayerChecksum(upperLayer, csum)
	folded := s.foldChecksum(csum)
	return folded, nil
}

// (joao) Verified
requires acc(s.Mem(), 1/100)
ensures acc(s.Mem(), 1/100)
ensures s.getLenRawSrcAddr() == 0 ==> resErr != nil
ensures s.getLenRawDstAddr() == 0 ==> resErr != nil
ensures s.getLenRawSrcAddr() > 0 && s.getLenRawDstAddr() > 0 ==> resErr == nil
func (s *SCION) pseudoHeaderChecksum(length int, protocol uint8) (resUint uint32, resErr error) {
	// (joao) len(s.RawDstAddr) replaced by s.getLenRawDstAddr() to avoid unfoldings
	// if len(s.RawDstAddr) == 0 {
	if s.getLenRawDstAddr() == 0 {
		return 0, serrors.New("destination address missing")
	}
	// (joao) len(s.RawSrcAddr) replaced by s.getLenRawSrcAddr() to avoid unfoldings
	// if len(s.RawSrcAddr) == 0 {
	if s.getLenRawSrcAddr() == 0 {
		return 0, serrors.New("source address missing")
	}
	var csum uint32
	var srcIA@, dstIA@ [8]byte

	// (joao) outlining this section causes Gobra to crash
	// s.SrcIA.Write(srcIA[:])
	// s.DstIA.Write(dstIA[:])
	// (joao) rewrote as:
	srcIASlice := srcIA[:]
	dstIASlice := dstIA[:]
	assert len(srcIASlice) == 8
	assert forall i int :: 0 <= i && i < 8 ==> &(srcIASlice)[i] == &srcIA[i]
	assert len(dstIASlice) == 8
	assert forall i int :: 0 <= i && i < 8 ==> &(dstIASlice)[i] == &dstIA[i]
	s.pseudoHeaderChecksumOutlineBlock1(srcIASlice, dstIASlice)
	assert forall i int :: 0 <= i && i < 8 ==> acc(&srcIA[i])
	assert forall i int :: 0 <= i && i < 8 ==> acc(&dstIA[i])

	invariant 0 <= i && i <= 8
	invariant i%2 == 0
	invariant forall i int :: 0 <= i && i < 8 ==> acc(&srcIA[i])
	invariant forall i int :: 0 <= i && i < 8 ==> acc(&dstIA[i])
	for i := 0; i < 8; i += 2 {
		csum += uint32(srcIA[i]) << 8
		csum += uint32(srcIA[i+1])
		csum += uint32(dstIA[i]) << 8
		csum += uint32(dstIA[i+1])
	}

	// Address length is guaranteed to be a multiple of 2 by the protocol.
	invariant acc(s.Mem(), 1/200)
	invariant s.getLenRawSrcAddr()%2 == 0
	invariant i%2 == 0
	invariant 0 <= i && i <= s.getLenRawSrcAddr()
	// (joao) len(s.RawSrcAddr) replaced by s.getLenRawSrcAddr() to avoid unfoldings
	// for i := 0; i < len(s.RawSrcAddr); i += 2 {
	for i := 0; i < s.getLenRawSrcAddr(); i += 2 {
		// (joao) added parentheses surrounding s.RawSrcAddr, otherwise does not parse
		// (joao) original:
		// csum += uint32(s.RawSrcAddr[i]) << 8
		// csum += uint32(s.RawSrcAddr[i+1])
		// (joao) the following rewrite used to work before grouping permissions to s.RawSrcAddr in an instance of BytesAcc:
		// csum += uint32(unfolding acc(s.Mem(), 1/400) in (s.RawSrcAddr)[i]) << 8
		// csum += uint32(unfolding acc(s.Mem(), 1/400) in (s.RawSrcAddr)[i+1])
		csum += uint32(s.getRawSrcAddrIdx(i)) << 8
		csum += uint32(s.getRawSrcAddrIdx(i+1))
	}

	invariant acc(s.Mem(), 1/200)
	invariant s.getLenRawDstAddr()%2 == 0
	invariant i%2 == 0
	invariant 0 <= i && i <= s.getLenRawDstAddr()
	// (joao) len(s.RawDstAddr) replaced by s.getLenRawSrcAddr() to avoid unfoldings
	// for i := 0; i < len(s.RawDstAddr); i += 2 {
	for i := 0; i < s.getLenRawDstAddr(); i += 2 {
		// (joao) added parentheses surrounding s.RawSrcAddr, otherwise does not parse
		// (joao) rewrite 1:
		// csum += uint32(unfolding acc(s.Mem(), 1/400) in (s.RawDstAddr)[i]) << 8
		// csum += uint32(unfolding acc(s.Mem(), 1/400) in (s.RawDstAddr)[i+1])
		csum += uint32(s.getRawDstAddrIdx(i)) << 8
		csum += uint32(s.getRawDstAddrIdx(i+1))
	}
	l := uint32(length)
	csum += (l >> 16) + (l & 0xffff)
	csum += uint32(protocol)
	return csum, nil
}

// (joao) Verified
requires len(srcIA) == 8 && len(dstIA) == 8
requires acc(s.Mem(), 1/200)
requires forall i int :: 0 <= i && i < 8 ==> acc(&srcIA[i])
requires forall i int :: 0 <= i && i < 8 ==> acc(&dstIA[i])
ensures  acc(s.Mem(), 1/200)
ensures  forall i int :: 0 <= i && i < 8 ==> acc(&srcIA[i])
ensures  forall i int :: 0 <= i && i < 8 ==> acc(&dstIA[i])
func (s *SCION) pseudoHeaderChecksumOutlineBlock1(srcIA []byte, dstIA []byte) {
	// (joao) Original code, omitted to avoid unfolding
	// s.SrcIA.Write(srcIA)
	(s.getSrcIA()).Write(srcIA)
	// (joao) Original code, omitted to avoid unfolding
	// s.DstIA.Write(dstIA)
	(s.getDstIA()).Write(srcIA)
}

// (joao) Verified
requires forall j int :: 0 <= j && j < len(upperLayer) ==> acc(&upperLayer[j], 1/10000)
ensures forall j int :: 0 <= j && j < len(upperLayer) ==> acc(&upperLayer[j], 1/10000)
func (s *SCION) upperLayerChecksum(upperLayer []byte, csum uint32) uint32 {
	// Compute safe boundary to ensure we do not access out of bounds.
	// Odd lengths are handled at the end.
	safeBoundary := len(upperLayer) - 1
	invariant safeBoundary == len(upperLayer) - 1
	invariant 0 <= i && i < safeBoundary + 2 && i%2 == 0
	invariant forall j int :: 0 <= j && j < len(upperLayer) ==> acc(&upperLayer[j], 1/20000)
	for i := 0; i < safeBoundary; i += 2 {
		csum += uint32(upperLayer[i]) << 8
		csum += uint32(upperLayer[i+1])
	}
	if len(upperLayer)%2 == 1 {
		csum += uint32(upperLayer[safeBoundary]) << 8
	}
	return csum
}

// (joao) Verified
func (s *SCION) foldChecksum(csum uint32) uint16 {
	for csum > 0xffff {
		csum = (csum >> 16) + (csum & 0xffff)
	}
	return ^uint16(csum)
}