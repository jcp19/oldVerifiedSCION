// Copyright 2016 ETH Zurich
// Copyright 2018 ETH Zurich, Anapaya Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package addr

// TODO: replace by relative path
// ##(-I /Users/joao/Code/verifiedScionGo/)

import (
	"encoding/binary"
	//"fmt"
	"net"
	"strings"

	"gobra/lib/common"
	"gobra/lib/serrors"
)

type HostAddrType uint8

const (
    // (joao) defined in terms of iota before
	HostTypeNone HostAddrType = 0
	HostTypeIPv4 HostAddrType = 1
	HostTypeIPv6 HostAddrType = 2
	HostTypeSVC HostAddrType = 3
)

func (t HostAddrType) String() string {
	switch t {
	case HostTypeNone:
		return "None"
	case HostTypeIPv4:
		return "IPv4"
	case HostTypeIPv6:
		return "IPv6"
	case HostTypeSVC:
		return "SVC"
	}
    // (joao) fmt.Sptrintf still not supported
	// return fmt.Sprintf("UNKNOWN (%d)", t)
}

const (
	HostLenNone = 0
	HostLenIPv4 = net.IPv4len
	HostLenIPv6 = net.IPv6len
	HostLenSVC  = 2
)

// (joao) no support for global variables
/*
var (
	// ErrBadHostAddrType indicates an invalid host address type.
	ErrBadHostAddrType = serrors.New("unsupported host address type")
	// ErrMalformedHostAddrType indicates a malformed host address type.
	ErrMalformedHostAddrType = serrors.New("malformed host address type")
	// ErrUnsupportedSVCAddress indicates an unsupported SVC address.
	ErrUnsupportedSVCAddress = serrors.New("unsupported SVC address")
)
*/

// (joao) used to be defined in hexadecimal
const (
	SvcDS       HostSVC = 1
	SvcCS       HostSVC = 2
	SvcSB       HostSVC = 3
	SvcSIG      HostSVC = 4
	SvcHPS      HostSVC = 5
	SvcWildcard HostSVC = 16
	SvcNone     HostSVC = 65535

	SVCMcast HostSVC = 32768
)

type HostAddr interface {
	Size() int
	Type() HostAddrType
	Pack() common.RawBytes
	IP() net.IP
	Copy() HostAddr
	Equal(HostAddr) bool
	// fmt.Stringer
}

// var _ HostAddr = (HostNone)(nil)

type HostNone net.IP

func (h HostNone) Size() int {
	return HostLenNone
}

func (h HostNone) Type() HostAddrType {
	return HostTypeNone
}

// (joao) Logic error: expected composite type but got DefinedT(RawBytes_common_T,Exclusive)
func (h HostNone) Pack() common.RawBytes // {
//	return common.RawBytes{}
//}

func (h HostNone) IP() net.IP {
	return nil
}

func (h HostNone) Copy() HostAddr // {
// (joao) Logic error: expected composite type but got DefinedT(HostNone_addr_T,Exclusive) 
//	return HostNone{}
// }

func (h HostNone) Equal(o HostAddr) bool // {
//	_, ok := o.(HostNone)
//	return ok
// }

func (h HostNone) String() string {
	return "<None>"
}

// var _ HostAddr = (HostIPv4)(nil)

type HostIPv4 net.IP

func (h HostIPv4) Size() int {
	return HostLenIPv4
}

func (h HostIPv4) Type() HostAddrType {
	return HostTypeIPv4
}

func (h HostIPv4) Pack() common.RawBytes //{
//	return common.RawBytes(h.IP())
// }

func (h HostIPv4) IP() net.IP {
	// XXX(kormat): ensure the reply is the 4-byte representation.
	// (joao) add parentheses surrounding net.IP(h) otherwise causes parser error
	return (net.IP(h)).To4()
}

func (h HostIPv4) Copy() HostAddr // {
//	return HostIPv4(append(net.IP(nil), h...))
// }

func (h HostIPv4) Equal(o HostAddr) bool // {
//	ha, ok := o.(HostIPv4)
//	return ok && net.IP(h).Equal(net.IP(ha))
// }

func (h HostIPv4) String() string {
	return (h.IP()).String() // (joao) add parentheses surrounding h.IP() otherwise causes parser error
}

// var _ HostAddr = (HostIPv6)(nil)

type HostIPv6 net.IP

func (h HostIPv6) Size() int {
	return HostLenIPv6
}

func (h HostIPv6) Type() HostAddrType {
	return HostTypeIPv6
}

func (h HostIPv6) Pack() common.RawBytes //{
//	return (common.RawBytes(h))[:HostLenIPv6]
//}

func (h HostIPv6) IP() net.IP {
	return net.IP(h)
}

func (h HostIPv6) Copy() HostAddr // {
//	return HostIPv6(append(net.IP(nil), h...))
// }

func (h HostIPv6) Equal(o HostAddr) bool {
	ha, ok := o.(HostIPv6)
	// (joao) put net.IP(h) inside parentheses, otherwise causes parser error
	return ok && (net.IP(h)).Equal(net.IP(ha))
}

func (h HostIPv6) String() string {
	// (joao) put h.IP() inside parentheses, otherwise causes parser error
	return (h.IP()).String()
}

// var _ HostAddr = (*HostSVC)(nil)

type HostSVC uint16

// HostSVCFromString returns the SVC address corresponding to str. For anycast
// SVC addresses, use BS_A, PS_A, CS_A, and SB_A; shorthand versions without
// the _A suffix (e.g., PS) also return anycast SVC addresses. For multicast,
// use BS_M, PS_M, CS_M, and SB_M.
func HostSVCFromString(str string) HostSVC {
	var m HostSVC
	switch {
	case strings.HasSuffix(str, "_A"):
		str = strings.TrimSuffix(str, "_A")
	case strings.HasSuffix(str, "_M"):
		str = strings.TrimSuffix(str, "_M")
		m = SVCMcast
	}
	switch str {
	/*
	case "DS":
		return SvcDS | m
	case "CS":
		return SvcCS | m
	case "SB":
		return SvcSB | m
	case "SIG":
		return SvcSIG | m
	case "Wildcard":
		return SvcWildcard | m
	*/
	default:
		return SvcNone
	}
}

func (h HostSVC) Size() int {
	return HostLenSVC
}

func (h HostSVC) Type() HostAddrType {
	return HostTypeSVC
}

func (h HostSVC) Pack() common.RawBytes /*{
	out := make(common.RawBytes, HostLenSVC)
	binary.BigEndian.PutUint16(out, uint16(h))
	return out
} */

requires HostLenSVC + pad >= 0 
func (h HostSVC) PackWithPad(pad int) []byte {
	out := make([]byte, HostLenSVC+pad)
	// binary.BigEndian.PutUint16(out, uint16(h))
	return out
}

func (h HostSVC) IP() net.IP {
	return nil
}

// (joao) no support for bitwise operators
func (h HostSVC) IsMulticast() bool // {
//	return (h & SVCMcast) != 0
// }

// (joao) no support for bitwise operators
func (h HostSVC) Base() HostSVC // {
// 	return h & ^HostSVC(SVCMcast)
// }

// (joao) no support for bitwise operators
func (h HostSVC) Multicast() HostSVC // {
//	return h | HostSVC(SVCMcast)
// }

func (h HostSVC) Copy() HostAddr {
	return h
}

func (h HostSVC) Equal(o HostAddr) bool {
	ha, ok := o.(HostSVC)
	return ok && h == ha
}

// (joao) no support for rune literals
func (h HostSVC) String() string {
	name := h.BaseString()
	// cast := 'A'
	if h.IsMulticast() {
		// cast = 'M'
	}
	// return fmt.Sprintf("%v %c (0x%04x)", name, cast, uint16(h))
}

// BaseString returns the upper case name of the service. For hosts or unrecognized services, it
// returns UNKNOWN.
func (h HostSVC) BaseString() string {
	switch h.Base() {
	case SvcDS:
		return "DS"
	case SvcCS:
		return "CS"
	case SvcSB:
		return "SB"
	case SvcSIG:
		return "SIG"
	case SvcWildcard:
		return "Wildcard"
	default:
		return "UNKNOWN"
	}
}

func (h HostSVC) Network() string {
	return ""
}

func HostFromRaw(b common.RawBytes, htype HostAddrType) (HostAddr, error) // {
//	switch htype {
//	case HostTypeNone:
//		return HostNone{}, nil
//	case HostTypeIPv4:
//		// (joao) no support for len(b) where b is of a declared type
//		if len(b) < HostLenIPv4 {
//			return nil, serrors.WithCtx(ErrMalformedHostAddrType, "type", htype)
//		}
//		return HostIPv4(b[:HostLenIPv4]), nil
//	case HostTypeIPv6:
//		// (joao) no support for len(b) where b is of a declared type
//		if len(b) < HostLenIPv6 {
//			return nil, serrors.WithCtx(ErrMalformedHostAddrType, "type", htype)
//		}
//		return HostIPv6(b[:HostLenIPv6]), nil
//		
//	case HostTypeSVC:
//		return HostSVC(binary.BigEndian.Uint16(b)), nil
//	default:
//		return nil, serrors.WithCtx(ErrBadHostAddrType, "type", htype)
//	}
//}

func HostFromIP(ip net.IP) HostAddr {
	if ip4 := ip.To4(); ip4 != nil {
		return HostIPv4(ip4)
	}
	return HostIPv6(ip)
}

func HostFromIPStr(s string) HostAddr {
	ip := net.ParseIP(s)
	if ip == nil {
		return nil
	}
	return HostFromIP(ip)
}

func HostLen(htype HostAddrType) (uint8, error) {
	var length uint8
	switch htype {
	case HostTypeNone:
		length = HostLenNone
	case HostTypeIPv4:
		length = HostLenIPv4
	case HostTypeIPv6:
		length = HostLenIPv6
	case HostTypeSVC:
		length = HostLenSVC
	// default:
	//	return 0, serrors.WithCtx(ErrBadHostAddrType, "type", htype)
	}
	return length, nil
}

func HostTypeCheck(t HostAddrType) bool {
	switch t {
	case HostTypeIPv6, HostTypeIPv4, HostTypeSVC:
		return true
	}
	return false
}