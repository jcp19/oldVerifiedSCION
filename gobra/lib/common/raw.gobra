// Copyright 2016 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package common

import (
	//"fmt"
)

// var _ Payload = (*RawBytes)(nil)

type RawBytes []byte

pred (r RawBytes) Mem() {
	forall i int :: 0 <= i && i < len(r) ==> acc(&r[i])
}

requires p > 0
requires acc(r.Mem(), p)
ensures acc(r.Mem(), p)
func (r RawBytes) String(ghost p perm) string //{
//  return fmt.Sprintf("%x", []byte(r))
//}

pure func (r RawBytes) Len() int {
	return len(r)
}

requires p > 0
requires acc(r.Mem(), p)
ensures  acc(r.Mem(), p)
ensures  res.Mem() && err == nil
func (r RawBytes) Copy(ghost p perm) (res Payload, err error) {
	unfold acc(r.Mem(), p)
	// (joao) introduced var `tmp` to allow folding and unfolding
	tmp := append(p, RawBytes{}, r...)
	fold acc(r.Mem(), p)
	fold tmp.Mem()
	return tmp, nil
}

requires 0 < p && p < 1
requires b.Mem()
requires acc(r.Mem(), p)
ensures  b.Mem()
ensures  acc(r.Mem(), p)
func (r RawBytes) WritePld(b RawBytes, ghost p perm) (int, error) {
	if len(b) < len(r) {
		// (joao) Gobra does not type check if the type conversion to ErrMsg is not present
		// return 0, NewBasicError("Insufficient space", nil, "expected", len(r), "actual", len(b))
		return 0, NewBasicError(ErrMsg("Insufficient space"), nil, "expected", len(r), "actual", len(b))
	}
	// (joao) introduced var `tmp` to be able to do the folds after the return statement
	unfold b.Mem()
	unfold acc(r.Mem(), p)
	tmp := copy(b, r, p)
	fold acc(r.Mem(), p)
	fold b.Mem()
	return tmp, nil
}

requires r.Mem()
ensures  r.Mem() && unfolding r.Mem() in forall i int :: 0 <= i && i < len(r) ==> r[i] == 0
func (r RawBytes) Zero() // {
//	for i := range r {
//		r[i] = 0
//	}
//}