package verifyutils

// Version of copy used to prove memory safety only
preserves forall i int :: (0 <= i && i < len(dst)) ==> acc(&dst[i])
preserves forall i int :: (0 <= i && i < len(src)) ==> acc(&src[i], 1/100000)
decreases
func OutlineMemorySafeCopy(dst, src []byte) {
	copy(dst, src, perm(1/1000000))
}

// Produces unknown string, useful to model unsupported operations that produce strings without requiring
// any permissions
func HavocString() string

pred BytesAcc(b []byte) {
	forall i int :: { b[i] } 0 <= i && i < len(b) ==> acc(&b[i])
}

requires acc(BytesAcc(b), _)
requires 0 <= i && i < len(b)
ensures v == unfolding acc(BytesAcc(b), _) in b[i]
pure func BytesIndex(b []byte, i int) (v byte) {
	return unfolding acc(BytesAcc(b), _) in b[i]
}

// Compares if two slices are equal. 
// The slices are equal if their lengths, capacities and addresses are the same
ghost
pure func ByteSlicesEqual(s1 []byte, s2 []byte) bool {
	return (len(s1) == len(s2)) && (cap(s1) == cap(s2)) && (forall i int :: 0 <= i && i < len(s1) ==> &s1[i] == &s2[i])
}