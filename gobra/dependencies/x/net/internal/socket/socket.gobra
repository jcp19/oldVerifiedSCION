package socket

import (
	"net"
)

const (
	bufSize = 9000
)

pred (m *Message) MemPartiallyInitialized() {
	acc(m) &&
	(len(m.Buffers) == 1) &&
	(forall i int :: 0 <= i && i < len(m.Buffers) ==> acc(&(m.Buffers)[i])) &&
	(forall j,k int :: 0 <= j && j < len(m.Buffers) && 0 <= k && k < cap((m.Buffers)[j]) ==> acc(&(m.Buffers)[j][k])) &&
	(forall i int :: 0 <= i && i < len(m.OOB) ==> acc(&(m.OOB)[i])) &&
	m.Addr.Mem()
}

pred (m *Message) Mem() {
	acc(m) &&
	(len(m.Buffers) == 1) &&
	(forall i int :: 0 <= i && i < len(m.Buffers) ==> acc(&(m.Buffers)[i])) &&
	(forall i int :: 0 <= i && i < len(m.Buffers) ==> cap((m.Buffers)[i]) == bufSize) &&
	(forall j,k int :: 0 <= j && j < len(m.Buffers) && 0 <= k && k < cap((m.Buffers)[j]) ==> acc(&(m.Buffers)[j][k])) &&
	(forall i int :: 0 <= i && i < len(m.OOB) ==> acc(&(m.OOB)[i])) &&
	m.Addr.Mem()
}

requires acc(m.Mem(), _)
pure func (m *Message) HasBuffersNonZeroLength() bool {
	return unfolding acc(m.Mem(), _) in len(m.Buffers) >= 1
}

// A Message represents an IO message.
type Message struct {
	// When writing, the Buffers field must contain at least one
	// byte to write.
	// When reading, the Buffers field will always contain a byte
	// to read.
	Buffers [][]byte

	// OOB contains protocol-specific control or miscellaneous
	// ancillary data known as out-of-band data.
	OOB []byte

	// Addr specifies a destination address when writing.
	// It can be nil when the underlying protocol of the raw
	// connection uses connection-oriented communication.
	// After a successful read, it may contain the source address
	// on the received packet.
	Addr net.Addr

	N     int // # of bytes read or written from/to Buffers
	NN    int // # of bytes read or written from/to OOB
	Flags int // protocol-specific information on the received message
}